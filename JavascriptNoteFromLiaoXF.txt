廖雪峰Javascript教程学习笔记
1、快速入门
Javascript代码可以直接嵌在任何地方，通常放在代码<head>中；还可以将代码放到单独的.js文件，通过<script src="..."></script>引用，放入单独的.js文件更利于维护，不同页面可引用同一份.js文件 
1.1. 基本语法
以//开头直到行末的字符为注释；另一种多行字符注释/* ... */
1.2. 数据类型和变量
六大数据类型：
数字（不区分整数和浮点数，NaN也是数字类型，不等于任何数字包括自身）；	字符串；	布尔值；	null（表示一个空值）；	undefined（值未定义）；	对象（数组也是对象）
定义变量时可以不指定数据类型，这是动态语言的特性;JS不强迫必须用var定义变量，如果不用var则该变量为全局变量，可以用delete删除，通过在代码顶部输入‘use strict’ 可以强制要var定义
1.3. 字符串
字符串是基本数据类型，其值不能改变，'或"要成为字符输出的一部分需要在前面加转义符\,转义符还可以转移其他，如\n 换行 \t 制表符 \x## 与之十六进制对应的ASCII字符 \u####unicode字符
ES6使用`进行多行字符表示：
`这是一个
多行
字符串`
字符串操作：
String.length 求字符串长度；	String.toUpperCase()大写；	String.toLowerCase()小写；	String.indexOf()搜索某字符串出现的位置，没找到返回-1；	String.substring(0,5)返回指定区间的字串，不包括结束位置
1.4. 数组
数组可以改变，通过索引赋值索引超过了范围会引起数组大小的变化。
数组操作：
arr.indexOf()搜索特定元素的位置
arr.slice(n,n) 字符串substring的对应版，截取一部分返回新的数组，同样不包括结尾元素
arr.push() 数组末尾添加元素； arr.pop() 数组末尾删除元素
arr.unshift() 数组头添加元素； arr.shift() 数组头删除元素
arr.sort() 对数组进行排序，直接改变数组
arr.reverse() 给数组元素反转，直接改变数组
arr.splice(n,n,'element1',...,'element2') 从索引位置删除若干元素，再在该位置添加元素，第一个数字表示索引位置，第二个表示删除个数,直接改变数组
arr.concat() 连接另一个数组合并成一个，不改变原来的数组，返回新的
arr.join() 将数组元素按指定连接符连接成字符串
1.5. 对象
对象属性名如果不是有效变量则需要''括起来，访问也必须用[]操作符；要检测某对象Object拥有某属性可以用in操作符：'name' in xiaoming 返回布尔值，但该属性有可能是继承的不是自带的，要检测是不是自带的用Object.hasOwnProperty()
1.6. 循环
for ... in 循环是for循环的变体，for(var key in Object){} 中key表示的是对象Object的属性变量名
1.7. Map和Set
JS的对象属性名必须是字符串，为了增加其他的数据类型，ES6引入了新的数据类型Map，Map是一组键值对的结构。初始化一个Map需要一个二维数组，方法如下：
var m = new Map([['A',32],['B',42],['C',41]]);
也可以初始化一个空的Map，通过命令来添加键值对，同一个键只能有一个值，不断对同一个键赋值，后面的会将前面的覆盖
var m = new Map();
m.set('A',21);
Set是一组键的集合，不储存值，键不能重复
var s1 = new Set([1,2,3]);
s1.add(5); s1.delete(3);
1.8. iterable
类似数组的下标循环，但数组下标循环不能遍历Map和Set，为此引入了iterable类型，数组，Map，Set都属于iterable类型，这种类型可以通过for ... of 循环遍历，for（var value of iterable）中value表示值与for in不同
更好的方式是使用iterable的forEach（）方法：
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
});

2、函数
函数如果没有return则返回undefined，调用函数时传入的参数比定义的多也不影响调用，传入的比定义的少则返回NaN；函数中有个关键字arguments，包含所有传入的参数，类似数组但不是数组；剩余参数rest，
function name（a,b, ...rest){} rest包含所有a，b以后的所有参数，如果参数没有传到rest则rest为空数组，而不是undefined。
2.1. 变量作用域和解构赋值
JS具有变量申明提前的特性，但赋值不会提前；为了防止全局变量名的冲突，建议将所有全局变量和函数都放到一个对象中；用var定义的变量只有函数作用，要是变量有块级作用域用let申明变量；JS没有常量申明，默认变量名全部大写来标明常量
对多个变量进行同时赋值使用解构赋值：var [x,y,z] = ['A','B','C'];对对象进行解构赋值，多个变量要用{}括起来：
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school'
};
var {name, age, passport} = person;如果对象属性名不存在则赋值undefined，如果要给属性名不一致的变量名赋值可以使用下面的方法：
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school'
};
// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
var {name,single=true} = person;如果属性不存在则使用默认值true
有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：
// 声明变量:
var x, y;
// 解构赋值:
{x, y} = { name: '小明', x: 100, y: 200};
// 语法错误: Uncaught SyntaxError: Unexpected token =
这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：
({x, y} = { name: '小明', x: 100, y: 200});
2.2. 方法 
对象中绑定的函数称为该对象的方法
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};
xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
this是特殊对象始终指向当前对象，如果将其拆开写：
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN，在strict模式下回得到错误
单独调用this指向了window对象
如果方法函数里还嵌套了函数，this又会指向window
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - this.birth;
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined
解决办法是用that先捕获this
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};
xiaoming.age(); // 25
要指定函数的this指向那个对象，可以用函数本身的apply方法，它接受两个参数，第一个是要绑定的this变量，第二个是数组，包含函数本身的参数，用法如下：
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
另一个与apply（）类似的方法是call（），唯一的区别是apply把参数打包再传入，call把参数按顺序传入，如：
Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
对于普通函数，将this绑定为null
2.3. 高阶函数
参数接受另一个函数的函数称之为高阶函数
2.4. 闭包
一个函数的返回值是另一个函数称之为闭包，借助闭包可以封装私有变量
2.5.箭头函数
ES6新增了一种箭头函数，其格式如下：
(x,y)=> {
	return x*y;
}
箭头函数如果是单表达式可以省略{}和return
(x,y)=> x*y;
注意，如果返回一个对象省略return这样写会报错
x => {foo:x}
{}与函数体的{}有冲突，解决办法是在对象外加一个小括号({foo:x})
箭头函数内部的this是词法作用域，修复了匿名函数this绑定错误的问题
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25
由于this在箭头函数中已经按照词法作用域绑定了，用call或者apply调用箭头函数无法进行绑定，传入的第一个参数被忽略
6. generator
generator是ES6的一种新数据类型，类似于函数；generator由function*定义，除了return还可以用yield返回多次，格式如下：
function* foo(x){
	yield x+1;
	yield x+2;
	return x+3;
}
用生成斐波那契举个例子
function* fib(max) {
    var
        t,
        a = 0,
        b = 1,
        n = 0;
    while (n < max) {
        yield a;
        [a, b] = [b, a + b];
        n ++;
    }
    return;
}
直接调用，结果如下
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
fib(5)仅仅创建了一个对象，还没有执行，调用generator对象有两种方法，一是不断调用generator对象的next()方法：
var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
value就是yield的返回值，done表示generator是否已经执行结束，done为true，value就是return的返回值
第二个方法是直接使用for ... of 循环迭代generator对象：
for (var x of fib(5)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
generator还有另一个好处，可以把异步回调代码变成同步代码，这个好处学了AJAX才能体会，例子如下
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
}

3. 标准对象
JS里一切都视为对象（广义），可以通过typeof操作符获取对象类型，它总是返回一个字符串，如：typeof null; // 'object'
包装对象，用new创建number、boolean、string的包装对象：
var n = new Number(123);  //123
var b = new Boolean(true);  //true
var s = new String('str');  //'str'
他们的值没有发生变化，但类型已经变成了object，建议不要使用包装对象.如果直接使用Number、boolean、和string会被当成普通函数，其功能是将任何数据类型转换为number、boolean和string基本数据类型，不是对象
用parseInt()或parseFloat()来转换任意类型到number；
用String()来转换任意类型为string，或调用某个对象（广义）的toString()方法（null虽然是对象，但没有toString方法；
判断是不是数组：Array.isArray(arr);		
数字直接使用tostring方法如123.tostring()会报错，需要改为123..toString() 或 (123).toString();原因可能是123.被当成了浮点数
3.1. Date
Date对象用来表示日期和时间，获取系统当前时间如下；
var now = new Date();
now.getFullYear();年份
now.getMonth();月份
now.getDate();多少号
now.getDay();星期
now.getHours();时
now.getMinutes();分
now.getSeconds();秒
now.getMilliseconds();毫秒
now.getTime();以时间形式表示的时间戳
var d = new Date(2015,5,19,20,15,30,123); // 创建一个指定日期和时间的 Date对象，注意月份从零开始，1表示二月以此类推
第二种创建指定日期的date对象的方法是解析一个符合ISO 8601格式的字符串，它得到的是一个时间戳，
var d = Date.parse('2015-06-24T19:49:22.875+08:00');
d; // 143514656287
通过新建Date对象转为常用格式
var d = new Date(1435146562875);
d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
Date对象表示浏览器所在时区时间，也可以显示调整后的UTC时间：
var d = new Date(1435146562875);
d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时
3.2. RegExp正则表达式
\d 匹配数字； \w 匹配数字或字母； . 匹配任意一个字符； * 匹配零个或多个任意字符； + 匹配至少一个字符； ？ 匹配零个或一个字符； {n} 表示n个字符，{n,m}n-m个字符
[]表示范围，[0-9a-zA-Z]匹配一个数字或者一个字母； A|B 匹配A或者B； ^\d以数字开头；  $\d以数字结尾；  /.../i 忽略大小写  /.../m 执行多行匹配
创建正则表达式有两种方法：直接通过/正则表达式/; new RegExp('正则表达式’)
var re1 = /ABC\-001/;\在//中无需转义
var re2 = new RegExp('ABC\\-001');
re1; // /ABC\-001/
re2; // /ABC\-001/
RegExp对象的test()方法用于测试给定的字符串是否符合条件
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
用正则表达式提取字串，()里是要提取的分组，使用exec()方法提取，返回一个数组：
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
正则匹配时贪婪匹配，会尽可能多的匹配字符：
var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
禁止贪婪匹配可以加一个?
var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']
全局匹配，即在字符串中进行多次匹配直到找出所有的匹配项
var r1 = /test/g;
// 等价于:
var r2 = new RegExp('test', 'g');
全局匹配会与/^...$/冲突，这样只会匹配一次
3.3.JSON
JSON是一种用于数据交换的格式，它可以是任何数据类型以及它们的任意组合。JSON的字符集必须是UTF-8.
将一个对象序列化为JSON格式的字符串
var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp']
};
var s = JSON.stringify(xiaoming);
如果要输出好看，加上参数，按缩进输出：
JSON.stringify(xiaoming, null,' ');//一个空格表示缩进输出
第二个参数可以控制如何筛选键值：
JSON.stringify(xiaoming, ['name', 'skills'], '  ');
{
  "name": "小明",
  "skills": [
    "JavaScript",
    "Java",
    "Python",
    "Lisp"
  ]
}
还可以传入一个函数，对象的键值对会被函数先处理
function convert(key, value) {
    if (typeof value === 'string') {
        return value.toUpperCase();
    }
    return value;
}
JSON.stringify(xiaoming, convert, '  ');字符串变为：
{
  "name": "小明",
  "age": 14,
  "gender": true,
  "height": 1.65,
  "grade": null,
  "middle-school": "\"W3C\" MIDDLE SCHOOL",
  "skills": [
    "JAVASCRIPT",
    "JAVA",
    "PYTHON",
    "LISP"
  ]
}
精确控制如何序列化对象，可以给对象定义一个toJSON()方法，直接返回应该序列化的数据
var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],
    toJSON: function () {
        return { // 只输出name和age，并且改变了key：
            'Name': this.name,
            'Age': this.age
        };
    }
};
JSON.stringify(xiaoming); // '{"Name":"小明","Age":14}'
反序列化，使用JSON.parse()把一个JSON格式的字符串还原成对象
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse()可以接受一个函数，用来转换解析出来的属性
var obj = JSON.parse('{"name":"小明","age":14}', function (key, value) {
    if (key === 'name') {
        return value + '同学';
    }
    return value;
});
console.log(JSON.stringify(obj)); // {name: '小明同学', age: 14}

4. 面向对象编程
JS中没有类和实例的概念，每个对象都是实例，JS是通过原型继承来实现面向对象编程的。
var Student = {
    name: 'Robot',
    height: 1.2,
    run: function () {
        console.log(this.name + ' is running...');
    }
};

var xiaoming = {
    name: '小明'
};
xiaoming.__proto__ = Student;
小明只有自己的name属性，其他都是从Student继承而来，如果将xiaoming指向其他的对象，之前继承对象的属性将不复存在
一般不直接用obj.__proto__去改变一个对象的原型，正确的方法是用Object.create()方法传入一个原型对象，并创建一个基于该原型的新对象，新对象没有任何自己的属性，需要添加
var Student = {
    name: 'Robot',
    height: 1.2,
    run: function () {
        console.log(this.name + ' is running...');
    }
};

function createStudent(name) {
    // 基于Student原型创建一个新对象:
    var s = Object.create(Student);
    // 初始化新对象:
    s.name = name;
    return s;
}

var xiaoming = createStudent('小明');
xiaoming.run(); // 小明 is running...
xiaoming.__proto__ === Student; // true
4.1. 创建对象
当访问一个对象的属性时，引擎先查找当前对象的属性，没有，查找其原型的对象上找，没有，到Object.prototype对象上找，没有，返回undefined
数组的原型链：arr ---> Array.prototype ---> Object.prototype ---> null 
函数原型链： functionName ---> Function.prototype ---> Object.prototype ---> null
使用new关键字和构造函数来创建一个对象。首先定义一个构造函数：
function Student(name) {
    this.name = name;
    this.hello = function () {
        alert('Hello, ' + this.name + '!');
    }
}
这实际是一个普通函数，利用关键字new来调用这个函数，会创建一个以该函数为原型的对象并返回这个对象，按照约定构造函数应当大写来区别普通函数：
var xiaoming = new Student('小明');
xiaoming.name; // '小明'
xiaoming.hello(); // Hello, 小明!
如果不写new这只是一个普通函数，返回undefined，写了new就是构造函数，它绑定的this指向新创建的对象，并默认返回this
新建对象xiaoming的原型链是：xiaoming ---> Student.prototype ---> Object.prototype ---> null
使用new Student() 创建的对象从原型上获得一个constructor属性，它指向函数Student本身，Student有个prototype属性，指向其原型对象
需要注意一点：
xiaoming.hello; // function: Student.hello()
xiaohong.hello; // function: Student.hello()
xiaoming.hello === xiaohong.hello; // false
虽然xiaoming和小红的方法代码一样，但是两个不同的函数
如果通过new Student()创建了很多对象，这些对象hello函数可以共享同一个函数，来节省空间，具体做法是将hello函数移动到Student.prototype对象上：
function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};
我们还可以编写一个createStudent()函数，在内部封装所有的new操作，
function Student(props) {
    this.name = props.name || '匿名'; // 默认值为'匿名'
    this.grade = props.grade || 1; // 默认值为1
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};

function createStudent(props) {
    return new Student(props || {})
}
这个createstudent()函数不需要new来调用；参数灵活，可以传，也可以不传

4.2 原型继承
在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。

由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。

但是办法还是有的。我们先回顾Student构造函数：
function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}
现在，我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：
function PrimaryStudent(props) {
    // 调用Student构造函数，绑定this变量:
    Student.call(this, props);
    this.grade = props.grade || 1;
}
但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是：
new PrimaryStudent() ----> PrimaryStudent.prototype ----> Object.prototype ----> null
必须想办法把原型链修改为：
new PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Object.prototype ----> null
我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现：
// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 空函数F:
function F() {
}

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: '小明',
    grade: 2
});
xiaoming.name; // '小明'
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true
注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。

如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：
function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
这个inherits()函数可以复用：
function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
JavaScript的原型继承实现方式就是：

定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；

借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；

继续在新的构造函数的原型上定义新方法。

4.3 class继承
在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。

有没有更简单的写法？有！

新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。

我们先回顾用函数实现Student的方法：
function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}
如果用新的class关键字来编写Student，可以这样写
class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert('Hello, ' + this.name + '!');
    }
}
比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {...}这样分散的代码。

最后，创建一个Student对象代码和前面章节完全一样：
var xiaoming = new Student('小明');
xiaoming.hello();
class继承

用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：
class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}
class继承

阅读: 50905
在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。

有没有更简单的写法？有！

新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。

我们先回顾用函数实现Student的方法：

function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}
如果用新的class关键字来编写Student，可以这样写：

class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert('Hello, ' + this.name + '!');
    }
}
比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {...}这样分散的代码。

最后，创建一个Student对象代码和前面章节完全一样：

var xiaoming = new Student('小明');
xiaoming.hello();
class继承

用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：

class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}
注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。

PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。

ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。

你一定会问，class这么好用，能不能现在就用上？

现在用还早了点，因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以试试Babel这


5. 浏览器
5.1 浏览器对象
JavaScript可以获取浏览器提供的很多对象，并进行操作
window对象
window对象不但充当全局作用域，而且表示浏览器窗口。

window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。

兼容性：IE<=8不支持。
// 可以调整浏览器窗口大小试试:
console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight);
对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。
navigator对象
navigator对象表示浏览器的信息，最常用的属性包括：

navigator.appName：浏览器名称；
navigator.appVersion：浏览器版本；
navigator.language：浏览器设置的语言；
navigator.platform：操作系统类型；
navigator.userAgent：浏览器设定的User-Agent字符串。
请注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本，例如：
var width;
if (getIEVersion(navigator.userAgent) < 9) {
    width = document.body.clientWidth;
} else {
    width = window.innerWidth;
}
但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：
var width = window.innerWidth || document.body.clientWidth;
screen

screen对象表示屏幕的信息，常用的属性有：

screen.width：屏幕宽度，以像素为单位；
screen.height：屏幕高度，以像素为单位；
screen.colorDepth：返回颜色位数，如8、16、24。
location对象
location对象表示当前页面的URL信息。例如，一个完整的URL：
http://www.example.com:8080/path/index.html?a=1&b=2#TOP
可以用location.href获取。要获得URL各个部分的值，可以这么写：
location.protocol; // 'http'
location.host; // 'www.example.com'
location.port; // '8080'
location.pathname; // '/path/index.html'
location.search; // '?a=1&b=2'
location.hash; // 'TOP'
要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。
if (confirm('重新加载当前页' + location.href + '?')) {
    location.reload();
} else {
    location.assign('/'); // 设置一个新的URL地址
}
document

document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。

document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变：
请观察浏览器窗口标题的变化。

要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。

我们先准备HTML数据：
<dl id="drink-menu" style="border:solid 1px #ccc;padding:6px;">
    <dt>摩卡</dt>
    <dd>热摩卡咖啡</dd>
    <dt>酸奶</dt>
    <dd>北京老酸奶</dd>
    <dt>果汁</dt>
    <dd>鲜榨苹果汁</dd>
</dl>
用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：
var menu = document.getElementById('drink-menu');
var drinks = document.getElementsByTagName('dt');
var i, s, menu, drinks;

menu = document.getElementById('drink-menu');
menu.tagName; // 'DL'

drinks = document.getElementsByTagName('dt');
s = '提供的饮料有:';
for (i=0; i<drinks.length; i++) {
    s = s + drinks[i].innerHTML + ',';
}
console.log(s);

document对象还有一个cookie属性，可以获取当前页面的Cookie。

Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)...，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。

Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。

JavaScript可以通过document.cookie读取到当前页面的Cookie：
由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：
<html>
    <head>
        <script src="http://www.foo.com/jquery.js"></script>
    </head>
    ...
</html>
如果引入的第三方的JavaScript中存在恶意代码，则www.foo.com网站将直接获取到www.example.com网站的用户登录信息。

为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。

为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。
history

history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。

这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。

新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。

任何情况，你都不应该使用history这个对象了。

5.2 操作DOM
取得DOM节点的方法：document.getElementById('IdName'), document.getElementByTagName()以及CSS选择器
ducument.getElementByClassName(). ID是唯一的，可以直接定位唯一的DOM节点。获取test节点的子节点：
test.firstElementChild .
第二种方法是使用querySelector()和querySelectorAll()
// 通过querySelector获取ID为q1的节点：
var q1 = document.querySelector('#q1');
// 通过querySelectorAll获取q1节点内的符合条件的所有节点：
var ps = q1.querySelectorAll('div.highlighted > p');
严格地讲，我们这里的DOM节点是指Element，但是DOM节点实际上是Node，在HTML中，Node包括Element、Comment
、CDATA_SECTION等很多种，以及根节点Document类型，但是，绝大多数时候我们只关心Element，也就是实际控
制页面结构的Node，其他类型的Node忽略即可。根节点Document已经自动绑定为全局变量document。

a.更新DOM
修改innerHTML属性，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：
/ 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置文本为abc:
p.innerHTML = 'ABC'; // <p id="p-id">ABC</p>
// 设置HTML:
p.innerHTML = 'ABC <span style="color:red">RED</span> XYZ';
// <p>...</p>的内部结构已修改
用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。
第二种是修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置HTML标签
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置文本:
p.innerText = '<script>alert("Hi")</script>';
// HTML被自动编码，无法设置一个<script>节点:
// <p id="p-id">&lt;script&gt;alert("Hi")&lt;/script&gt;</p>
使用textContent的不同在于他会返回所有文本，而innerText不返回隐藏文本
修改CSS也是经常需要的操作。DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size
这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize：
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置CSS:
p.style.color = '#ff0000';
p.style.fontSize = '20px';
p.style.paddingTop = '2em';

b.插入DOM
使用appendChild把一个子节点添加到父节点的最后一个子节点
<p id="js">JavaScript</p>
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
</div>
var
    js = document.getElementById('js'),
    list = document.getElementById('list');
list.appendChild(js);
更多的时候我们会从零创建一个新的节点，然后插入到指定位置：
var
    list = document.getElementById('list'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.appendChild(haskell);
如果我们要把子节点插入到指定的位置怎么办？可以使用parentElement.insertBefore(newElement,
referenceElement);，子节点会插入到referenceElement之前。还是以上面的HTML为例，假定我们要
把Haskell插入到Python之前：
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
</div>
var
    list = document.getElementById('list'),
    ref = document.getElementById('python'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.insertBefore(haskell, ref);
可见，使用insertBefore重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有
子节点，可以通过迭代children属性实现：
var
    i, c,
    list = document.getElementById('list');
for (i = 0; i < list.children.length; i++) {
    c = list.children[i]; // 拿到第i个子节点
}

c.删除DOM
要删除一个节点，首先要获得该节点本身和父节点，然后调用父节点的removeChild删除
// 拿到待删除节点:
var self = document.getElementById('to-be-removed');
// 拿到父节点:
var parent = self.parentElement;
// 删除:
var removed = parent.removeChild(self);
removed === self; // true
节点的children属性时刻都在变化

5.3 操作表单
HTML表单的输入控件主要有以下几种：
文本框，<input type="text">
口令框，<input type="password">
单选框，<input type="radio">
复选框，<input type="checkbox">
下拉框，<select>
隐藏文本，<input type="hidden">,用户不可见，但表单提交会把隐藏文本发送到服务器
调用value可以获得用户输入值
// <input type="text" id="email">
var input = document.getElementById('email');
input.value; // '用户输入的值'
但对于单选框和复选框，value属性返回的永远是预设的值，判断是否勾上了选项，用checked判断：
// <label><input type="radio" name="weekday" id="monday" value="1"> Monday</label>
// <label><input type="radio" name="weekday" id="tuesday" value="2"> Tuesday</label>
var mon = document.getElementById('monday');
var tue = document.getElementById('tuesday');
mon.value; // '1'
tue.value; // '2'
mon.checked; // true或者false
tue.checked; // true或者false
HTML5控件包括date、datetime、datetime-local、color
Javascript可以以两种方式来处理表单的提交
方式一通过<form>元素的submit()方法提交：
<form id="test-form">
    <input type="text" name="test">
    <button type="button" onclick="doSubmitForm()">Submit</button>
</form>

<script>
function doSubmitForm() {
    var form = document.getElementById('test-form');
    // 可以在此修改form的input...
    // 提交form:
    form.submit();
}
</script>
这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<button type="submit">时提交表单，
或者用户在最后一个输入框按回车键。因此，第二种方式是响应<form>本身的onsubmit事件，在提交form
时作修改：
<form id="test-form" onsubmit="return checkForm()">
    <input type="text" name="test">
    <button type="submit">Submit</button>
</form>

<script>
function checkForm() {
    var form = document.getElementById('test-form');
    // 可以在此修改form的input...
    // 继续下一步:
    return true;
}
</script>
很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。
普通JavaScript开发人员会直接修改<input>：
<form id="login-form" method="post" onsubmit="return checkForm()">
    <input type="text" id="username" name="username">
    <input type="password" id="password" name="password">
    <button type="submit">Submit</button>
</form>

<script>
function checkForm() {
    var pwd = document.getElementById('password');
    // 把用户输入的明文变为MD5:
    pwd.value = toMD5(pwd.value);
    // 继续下一步:
    return true;
}
</script>
这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个*变成32个*（因为MD5有32个字符）。
要想不改变用户的输入，可以利用<input type="hidden">实现：
<form id="login-form" method="post" onsubmit="return checkForm()">
    <input type="text" id="username" name="username">
    <input type="password" id="input-password">
    <input type="hidden" id="md5-password" name="password">
    <button type="submit">Submit</button>
</form>

<script>
function checkForm() {
    var input_pwd = document.getElementById('input-password');
    var md5_pwd = document.getElementById('md5-password');
    // 把用户输入的明文变为MD5:
    md5_pwd.value = toMD5(input_pwd.value);
    // 继续下一步:
    return true;
}
</script>

5.4 操作文件
上传文件的控件<input type="file">,当一个表单包含<input type="file">时，表单的enctype必须指定
为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发
送表单的数据。出于安全考虑，浏览器只允许用户点击<input type="file">来选择本地文件，用JavaScript
对<input type="file">的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无
法获得该文件的真实路径：
对文件扩展名做检查，以防无效格式文件：
var f = document.getElementById('test-file-upload');
var filename = f.value; // 'C:\fakepath\test.png'
if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) {
    alert('Can only upload image file.');
    return false;
}
由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用
Flash这样的第三方插件来实现。随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得
更多的文件信息。HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。
下面的例子演示了如何读取用户选取的图片文件，并在一个<div>中预览图像：
var
    fileInput = document.getElementById('test-image-file'),
    info = document.getElementById('test-file-info'),
    preview = document.getElementById('test-image-preview');
// 监听change事件:
fileInput.addEventListener('change', function () {
    // 清除背景图片:
    preview.style.backgroundImage = '';
    // 检查文件是否选择:
    if (!fileInput.value) {
        info.innerHTML = '没有选择文件';
        return;
    }
    // 获取File引用:
    var file = fileInput.files[0];
    // 获取File信息:
    info.innerHTML = '文件: ' + file.name + '<br>' +
                     '大小: ' + file.size + '<br>' +
                     '修改: ' + file.lastModifiedDate;
    if (file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') {
        alert('不是有效的图片文件!');
        return;
    }
    // 读取文件:
    var reader = new FileReader();
    reader.onload = function(e) {
        var
            data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            
        preview.style.backgroundImage = 'url(' + data + ')';
    };
    // 以DataURL的形式读取文件:
    reader.readAsDataURL(file);
});
上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似
于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...，常用于设置图像。如果需要服务器端处理，
把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。
Javascript的一个重要特性是单线程执行模式，任何时候Javascript代码都不可能有多于一个线程在执行，
Javascript执行多任务实际都是异步调用，比如下面的代码：
reader.readAsDataURL(file);
就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，
因此需要先设置一个回调函数：
reader.onload = function(e) {
    // 当文件读取完成后，自动调用此函数:
};
当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，
所以我们可以在回调函数内部安全地获得文件内容。

5.5 AJAX
AJAX就是用Javascript执行异步网络请求。
使用XMLHttpRequest对象写AJAX：
function success(text) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = 'Error code: ' + code;
}

var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open('GET', '/api/categories');
request.send();
alert('请求已发送，请等待响应...');
对于低版本的IE需要换一个ActiveXObject对象
var request = new ActiveXObject('Microsoft.XMLHTTP'); // 新建Microsoft.XMLHTTP对象
如果混合标准写法和IE写法可以这样：
var request;
if (window.XMLHttpRequest) {
    request = new XMLHttpRequest();
} else {
    request = new ActiveXObject('Microsoft.XMLHTTP');
}
注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符
串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。
当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只
需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。
XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，
第三个参数指定是否使用异步，默认是true，所以不用写。最后调用send()方法才真正发送请求。GET请求
不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。
安全限制：
上面代码的URL使用的是相对路径。如果你把它改为'http://www.sina.com.cn/'，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。
这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。
完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同）
，端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数
浏览器都会严格遵守这个限制。
Javascript请求外域URL方法：
a. 通过Flash插件发送HTTP请求； b. 通过同源域名下架设一个代理服务器来转发 c. 使用JSONP（只能用get请求）
新的跨域策略CORS（需浏览器支持HTML5）全称Cross-ORigin Resource Sharing
Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，
首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败
，JavaScript将无法获取到响应的任何数据。假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，
或者是*，本次请求就可以成功。可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的
Access-Control-Allow-Origin，决定权始终在对方手中。上面这种跨域请求，称之为“简单请求”。简单
请求包括GET、HEAD和POST（POST的Content-Type类型仅限application/x-www-form-urlencoded、
multipart/form-data和text/plain），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能
满足90%的需求。

5.6 promise
回顾下AJAX典型的异步操作：
request.onreadystatechange = function () {
    if (request.readyState === 4) {
        if (request.status === 200) {
            return success(request.responseText);
        } else {
            return fail(request.status);
        }
    }
}
把回调函数success(request.responseText)和fail(request.status)写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。
可以写成这样：
var ajax = ajaxGet('http://...');
ajax.ifSuccess(success)
    .ifFail(fail);
这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败
，在将来的某个时候调用success函数或fail函数。古人云：“君子一诺千金”，这种“承诺将来会执行”的对
象在JavaScript中称为Promise对象。
一个生成0-2之间的随机数，如果小于1则等一段时间返回成功，否则返回失败：
function test(resolve, reject) {
    var timeOut = Math.random() * 2;
    log('set timeout to: ' + timeOut + ' seconds.');
    setTimeout(function () {
        if (timeOut < 1) {
            log('call resolve()...');
            resolve('200 OK');
        }
        else {
            log('call reject()...');
            reject('timeout in ' + timeOut + ' seconds.');
        }
    }, timeOut * 1000);
}
这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve('200 OK')，如果执行失败，
我们将调用reject('timeout in ' + timeOut + ' seconds.')。可以看出，test()函数只关心自身的逻辑，
并不关心具体的resolve和reject将如何处理结果。有了执行函数，我们就可以用一个Promise对象来执行它，
并在将来某个时刻获得成功或失败的结果：
var p1 = new Promise(test);
var p2 = p1.then(function (result) {
    console.log('成功：' + result);
});
var p3 = p2.catch(function (reason) {
    console.log('失败：' + reason);
});
Promise对象可以串联起来，所以上述代码可以简化为：
new Promise(test).then(function (result) {
    console.log('成功：' + result);
}).catch(function (reason) {
    console.log('失败：' + reason);
})
下面的例子演示了如何串行执行一系列需要异步计算获得结果的任务：
'use strict';
var logging = document.getElementById('test-promise2-log');
while (logging.children.length > 1) {
    logging.removeChild(logging.children[logging.children.length - 1]);
}

function log(s) {
    var p = document.createElement('p');
    p.innerHTML = s;
    logging.appendChild(p);
}
// 0.5秒后返回input*input的计算结果:
function multiply(input) {
    return new Promise(function (resolve, reject) {
        log('calculating ' + input + ' x ' + input + '...');
        setTimeout(resolve, 500, input * input);
    });
}

// 0.5秒后返回input+input的计算结果:
function add(input) {
    return new Promise(function (resolve, reject) {
        log('calculating ' + input + ' + ' + input + '...');
        setTimeout(resolve, 500, input + input);
    });
}

var p = new Promise(function (resolve, reject) {
    log('start new Promise...');
    resolve(123);
});

p.then(multiply)
 .then(add)
 .then(multiply)
 .then(add)
 .then(function (result) {
    log('Got value: ' + result);
});
setTimeout可以看成一个模拟网络等异步执行的函数。现在，我们把上一节的AJAX异步执行函数转换为
Promise对象，看看用Promise如何简化异步处理：
'use strict';

// ajax函数将返回Promise对象:
function ajax(method, url, data) {
    var request = new XMLHttpRequest();
    return new Promise(function (resolve, reject) {
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    resolve(request.responseText);
                } else {
                    reject(request.status);
                }
            }
        };
        request.open(method, url);
        request.send(data);
    });
}
var log = document.getElementById('test-promise-ajax-result');
var p = ajax('GET', '/api/categories');
p.then(function (text) { // 如果AJAX成功，获得响应内容
    log.innerText = text;
}).catch(function (status) { // 如果AJAX失败，获得响应代码
    log.innerText = 'ERROR: ' + status;
});
除了串行执行若干异步任务外，Promise还可以并行执行异步任务，用Promise.all()实现如下：
var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
// 同时执行p1和p2，并在它们都完成后执行then:
Promise.all([p1, p2]).then(function (results) {
    console.log(results); // 获得一个Array: ['P1', 'P2']
});
有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的
结果即可。这种情况下，用Promise.race()实现：
var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
Promise.race([p1, p2]).then(function (result) {
    console.log(result); // 'P1'
});
由于p1执行较快，Promise的then()将获得结果'P1'。p2仍在继续执行，但执行结果将被丢弃。

5.7 Canvas
canvas是HTML5新增的组件，像一块布可以用Javascript在上面绘制图表、动画
用Canvas定义一个指定尺寸的矩形框：
<canvas id="test-canvas" width="300" height="200"></canvas>
由于浏览器对HTML5标准支持不一致，所以，通常在<canvas>内部添加一些说明性HTML代码，如果浏览器支持
Canvas，它将忽略<canvas>内部的HTML，如果浏览器不支持Canvas，它将显示<canvas>内部的HTML：
<canvas id="test-stock" width="300" height="200">
    <p>Current Price: 25.51</p>
</canvas>
getContext('2d')方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。
var ctx = canvas.getContext('2d');
如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：
gl = canvas.getContext("webgl");
Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。
'use strict';

var
    canvas = document.getElementById('test-shape-canvas'),
    ctx = canvas.getContext('2d');
ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
ctx.fillStyle = '#dddddd'; // 设置颜色
ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色
// 利用Path绘制复杂路径:
var path=new Path2D();
path.arc(75, 75, 50, 0, Math.PI*2, true);
path.moveTo(110,75);
path.arc(75, 75, 35, 0, Math.PI, false);
path.moveTo(65, 65);
path.arc(60, 65, 5, 0, Math.PI*2, true);
path.moveTo(95, 65);
path.arc(90, 65, 5, 0, Math.PI*2, true);
ctx.strokeStyle = '#0000ff';
ctx.stroke(path);
绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：
'use strict';

var
    canvas = document.getElementById('test-text-canvas'),
    ctx = canvas.getContext('2d');
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.shadowOffsetX = 2;
ctx.shadowOffsetY = 2;
ctx.shadowBlur = 2;
ctx.shadowColor = '#666666';
ctx.font = '24px Arial';
ctx.fillStyle = '#333333';
ctx.fillText('带阴影的文字', 20, 40);
Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：
通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；
尽量使用整数坐标而不是浮点数；
可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；
背景图片如果不变可以直接用<img>标签并放到最底层。


6. jQuery
jQuery 是Javascript使用最广泛的一个库，它能帮我们干这些事：
消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；
简洁的操作DOM的方法：写$('#test')肯定比document.getElementById('test')来得简洁；
轻松实现动画、修改CSS等各种操作。
目前jQuery有1.x和2.x两个主要版本，区别在于2.x移除了对IE6，7,8的支持。从jQuery官网可以下载最新的
版本，只是一个文件有compressed和uncompressed两个版本，使用是一样的，想深入研究使用未压缩版
使用jQuery只需在页面的<head>引入jQuery文件即可：
<head>
    <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
    ...
</head>
$是著名的jQuery符号，jQuery把所有功能封装在一个全局变量jQuery中，$是jQuery的别名
window.jQuery; // jQuery(selector, context)
window.$; // jQuery(selector, context)
$ === jQuery; // true
typeof($); // 'function'
$本质上就是一个函数，但是函数也是对象，于是$除了可以直接调用外，也可以有很多其他属性。
注意，你看到的$函数名可能不是jQuery(selector, context)，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的jQuery源码$函数可能变成a(b, c)。
绝大多数时候，我们都直接用$（因为写起来更简单嘛）。但是，如果$这个变量不幸地被占用了，而且还不能改，那我们就只能让jQuery把$变量交出来，然后就只能使用jQuery这个变量：

6.1 选择器
按某个DOM节点的ID查找：
var div = $('#abc'); //#表示ID，返回的对象是jQuery对象
如果没有ID为abc的节点，将返回[],总之jQuery不会返回undefined或者null
jQuery对象和DOM对象之间可以相互转化
var div = $('#abc'); // jQuery对象
var divDom = div.get(0); // 假设存在div，获取第1个DOM元素
var another = $(divDom); // 重新把DOM包装为jQuery对象
按tag查找
var ps = $('p'); //返回所有的<p>节点
ps.length; //数一数有多少个<p>节点
按class查找
var a = $('.red'); 
同时查找包含多个class的节点：
var a = $('.red.green');//没有空格
按属性查找
var email = $('[name=email]');
var passwordInput = $('[type=password]'); // 找出<??? type="password">
var a = $('[items="A B"]'); // 找出<??? items="A B">
当属性的值包含空格等特殊字符时，需要用双引号括起
按属性查找还可以使用前缀查找或者后缀查找：
var icons = $('[name^=icon]');找出所有name属性值以icon开头的DOM
var name = $('name$=with]');找出所有name属性值以with结尾的DOM
组合查找
var emailInput =$('input[name=email]'); //找出input标签里name属性为email的节点
var tr = $('tr.red'); //找出tr节点里class为red的节点
多项选择器
多项选择器是把多个选择用,组合起来一块选
$('p,div'); //选出<p>和<div>
$('p.red,p.green');
要注意的是，选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素。例如，<p class="red green">不会被上面的$('p.red,p.green')选择两次
6.11 层级选择器
如果两个DOM元素具有层级关系，可以用$('ancestor descendant')来选择，层级之间用空格隔开
<div class="testing">
    <ul class="lang">
        <li class="lang-javascript">JavaScript</li>
        <li class="lang-python">Python</li>
        <li class="lang-lua">Lua</li>
    </ul>
</div>
用层级选择器选出Javascript
$('ul.lang li.lang-javascript');
$('div.testing li.lang-javascript'); // 中间间隔了节点也是可以的
$('ul.lang li');// 选择所有的<li>节点
$('form.test p input'); //多层选择
子选择器
子选择器$('parent>child')类似层级选择器，但是限定了层级关系必须是父子关系，就是<child>节点
必须是<parent>节点的直属子节点
$('ul.lang>li.lang-javascript'); // 可以选出[<li class="lang-javascript">JavaScript</li>]
$('div.testing>li.lang-javascript'); // [], 无法选出，因为<div>和<li>不构成父子关系
过滤器
过滤器一般不单独使用，通常附加在选择器上，帮助更精准的定位元素
$('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点
$('ul.lang li:first-child'); // 仅选出JavaScript
$('ul.lang li:last-child'); // 仅选出Lua
$('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始
$('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素
$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素
与表单相关的过滤器
    :input：可以选择<input>，<textarea>，<select>和<button>；

    :file：可以选择<input type="file">，和input[type=file]一样；

    :checkbox：可以选择复选框，和input[type=checkbox]一样；

    :radio：可以选择单选框，和input[type=radio]一样；

    :focus：可以选择当前输入焦点的元素，例如把光标放到一个<input>上，用$('input:focus')就可以选出；

    :checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$('input[type=radio]:checked')；

    :enabled：可以选择可以正常输入的<input>、<select>
    等，也就是没有灰掉的输入；

    :disabled：和:enabled正好相反，选择那些不能输入的。
此外，jQuery还有很多有用的选择器，例如，选出可见的或隐藏的元素：
$('div:visible'); // 所有可见的div
$('div:hidden'); // 所有隐藏的div

6.12 查找和过滤
通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个
对象为基准，进行查找和过滤。最常见的查找是在某个节点的所有子节点中查找，使用find()方法，它本
身又接收一个任意的选择器。
<ul class="lang">
    <li class="js dy">JavaScript</li>
    <li class="dy">Python</li>
    <li id="swift">Swift</li>
    <li class="dy">Scheme</li>
    <li name="haskell">Haskell</li>
</ul>
用find()查找
var ul = $('ul.lang');
var dy = ul.find('.dy')
var swf =ul.find('#swift');
从当前节点向上查找，使用parent()方法
var swf = $('#swift');
var parent = swf.parent(); //获得上层父节点
var a = swf.parent('.red'); //上层节点如果不符合条件则返回空jQuery对象
同级节点可以通过next()和prev()方法 
var swift = $('#swift');
swift.next(); // Scheme
swift.next('[name=haskell]'); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]
swift.prev(); // Python
swift.prev('.dy'); // Python，因为Python同时符合过滤器条件.dy
过滤 
filter()方法留下符合过滤条件的节点
var langs = $('ul.lang li');
var a =langs.filter('.dy');
或者传入一个函数，注意函数内部的this绑定为DOM对象，不是jQuery对象
var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
langs.filter(function () {
    return this.innerHTML.indexOf('S') === 0; // 返回S开头的节点
}); // 拿到Swift, Scheme
map()方法把一个jQuery对象包含的若干DOM节点转化为其他对象
var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var arr = langs.map(function () {
    return this.innerHTML;
}).get(); // 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']
此外，一个jQuery对象如果包含了不止一个DOM节点，first()、last()和slice()方法可以返回一个新的
jQuery对象，把不需要的DOM节点去掉：
var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell
var js = langs.first(); // JavaScript，相当于$('ul.lang li:first-child')
var haskell = langs.last(); // Haskell, 相当于$('ul.lang li:last-child')
var sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致

6.2操作DOM
修改texthe HTML 
jQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本
<ul id="test-ul">
    <li class="js">JavaScript</li>
    <li name="book">Java &amp; JavaScript</li>
</ul>
$('#test-ul li[name=book]').text(); // 'Java & JavaScript'
$('#test-ul li[name=book]').html(); // 'Java &amp; JavaScript' 
如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用text()是获取文本，传入参数就变成设置文
本，HTML也是类似操作
一个jQuery对象可以包含0个或多个DOM对象，它的方法实际上会作用在对应的每个DOM节点
$('#test-ul li').text('JS'); //两个节点都变成了JS
所以jQuery对象的另一个好处是我们可以执行一个操作，作用在对应的一组DOM节点上。即使选择器没有返
回任何DOM节点，调用jQuery对象的方法仍然不会报错：
$('#not-exist').text('Hello'); // 代码不报错，没有节点被设置为'Hello'
这意味着jQuery可以免去许多if语句
修改CSS
jQuery对象有批量操作的特点，修改CSS非常方便
<ul id="test-css">
    <li class="lang dy"><span>JavaScript</span></li>
    <li class="lang"><span>Java</span></li>
    <li class="lang dy"><span>Python</span></li>
    <li class="lang"><span>Swift</span></li>
    <li class="lang dy"><span>Scheme</span></li>
</ul>
要高亮显示动态语言，调用jQuery对象的css('name', 'value')方法，我们用一行语句实现：
$('#test-css li.dy>span').css('background-color','#ffd351').css('color','red');
注意，jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），这样我们可以进行链式调用，非常方便
CSS()还可以这样用：
var div =$('#test-div');
div.css('color'); //获取css属性
div.css('color','#366699'); //设置css属性
div.css('color','');//清除css属性
为了和JavaScript保持一致，CSS属性可以用'background-color'和'backgroundColor'两种格式。
css()方法将作用于DOM节点的style属性，具有最高优先级。如果要修改class属性，可以用jQuery提供的下列方法：
var div = $('#test-div');
div.hasClass('highlight'); // false， class是否包含highlight
div.addClass('highlight'); // 添加highlight这个class
div.removeClass('highlight'); // 删除highlight这个class
显示和隐藏DOM
要隐藏一个DOM，我们可以设置CSS的display属性为none，利用css()方法就可以实现。不过，要显示这个
DOM就需要恢复原有的display属性，这就得先记下来原有的display属性到底是block还是inline还是别的
值。考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供show()和hide()方法，我们不用关心它是如
何修改display属性的，总之它能正常工作：
var a = $('a[target=_blank]');
a.hide(); // 隐藏
a.show(); // 显示
注意，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。
获取DOM信息
利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码：
// 浏览器可视窗口大小:
$(window).width(); // 800
$(window).height(); // 600

// HTML文档大小:
$(document).width(); // 800
$(document).height(); // 3500

// 某个div的大小:
var div = $('#test-div');
div.width(); // 600
div.height(); // 300
div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效
div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效
attr()和removeAttr()方法用于操作DOM节点的属性
<div id="test-div" name="Test" start="1">...</div>
var div = $('#test-div');
div.attr('data'); // undefined, 属性不存在
div.attr('name'); // 'Test'
div.attr('name', 'Hello'); // div的name属性变为'Hello'
div.removeAttr('name'); // 删除name属性
div.attr('name'); // undefined
prop()方法和attr()类似，但是HTML5规定有一种属性在DOM节点中可以没有值，只有出现与不出现两种，例如：
<input id="test-radio" type="radio" name="test" checked value="1">
等价于：
<input id="test-radio" type="radio" name="test" checked="checked" value="1">
attr()和prop()对于属性checked处理有所不同：
var radio = $('#test-radio');
radio.attr('checked'); // 'checked'
radio.prop('checked'); // true
prop()返回值更合理一些。不过，用is()方法判断更好：
var radio = $('#test-radio');
radio.is(':checked'); // true
类似的属性还有selected，处理时最好用is(':selected')。
操作表单
对于表单元素，jQuery对象统一提供val()方法获取和设置对应的value属性：
/*
    <input id="test-input" name="email" value="">
    <select id="test-select" name="city">
        <option value="BJ" selected>Beijing</option>
        <option value="SH">Shanghai</option>
        <option value="SZ">Shenzhen</option>
    </select>
    <textarea id="test-textarea">Hello</textarea>
*/
var
    input = $('#test-input'),
    select = $('#test-select'),
    textarea = $('#test-textarea');

input.val(); // 'test'
input.val('abc@example.com'); // 文本框的内容已变为abc@example.com
select.val(); // 'BJ'
select.val('SH'); // 选择框已变为Shanghai
textarea.val(); // 'Hello'
textarea.val('Hi'); // 文本区域已更新为'Hi'

修改DOM结构
直接使用浏览器提供的API对DOM结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。有了
jQuery，我们就专注于操作jQuery对象本身，底层的DOM操作由jQuery完成就可以了，这样一来，修改DOM
也大大简化了。
添加DOM
要添加新的DOM节点，除了通过jQuery的html()这种暴力方法外，还可以用append()方法，例如：
<div id="test-div">
    <ul>
        <li><span>JavaScript</span></li>
        <li><span>Python</span></li>
        <li><span>Swift</span></li>
    </ul>
</div>
var ul = $('#test-div>ul');
ul.append('<li><span>Haskell</span></li>');
除了接受字符串，append()还可以传入原始的DOM对象，jQuery对象和函数对象：
// 创建DOM对象:
var ps = document.createElement('li');
ps.innerHTML = '<span>Pascal</span>';
// 添加DOM对象:
ul.append(ps);

// 添加jQuery对象:
ul.append($('#scheme'));

// 添加函数对象:
ul.append(function (index, html) {
    return '<li><span>Language - ' + index + '</span></li>';
});
传入函数时，要求返回一个字符串、DOM对象或者jQuery对象。因为jQuery的append()可能作用于一组DOM节点，只有传入函数才能针对每个DOM生成不同的子节点。
append()把DOM添加到最后，prepend()则把DOM添加到最前。
另外注意，如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，也就是说，用append()，你可以移动一个DOM节点。
如果要把新节点插入到指定位置，例如，JavaScript和Python之间，那么，可以先定位到JavaScript，然后用after()方法：
var js = $('#test-div>ul>li:first-child');
js.after('<li><span>Lua</span></li>');
也就是说，同级节点可以用after()或者before()方法。
删除节点
要删除DOM节点，拿到jQuery对象后直接调用remove()方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点：
var li = $('#test-div>ul>li');
li.remove();

6.3 事件
因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。
浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。
由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。
点击连接，弹出提示框：
<a id="test-link" href="#0">点我试试</a>
var a = $('#test-link');
a.on('click',function(){
	alert('Hello!');
});
还可以直接调用click()方法
a.click(function(){
	alert("Hello!");
});
jQuery能绑定的事件主要包括：
鼠标事件：
click: 鼠标单击时触发； 
dblclick：鼠标双击时触发；
 mouseenter：鼠标进入时触发；
 mouseleave：鼠标移出时触发； 
 mousemove：鼠标在DOM内部移动时触发； 
 hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave
键盘事件
键盘事件仅作用在当前焦点的DOM上，通常是<input>和<textarea>。
keydown：键盘按下时触发；
keyup：键盘松开时触发；
keypress：按一次键后触发。
其他事件
focus：当DOM获得焦点时触发； 
blur：当DOM失去焦点时触发； 
change：当<input>、<select>或<textarea>的内容改变时触发； 
submit：当<form>提交时触发； 
ready：当页面被载入并且DOM树完成初始化后触发。
其中，ready仅作用于document对象。由于ready事件在DOM完成初始化后触发，且只触发一次，所以非常适
合用来写其他的初始化代码。假设我们想给一个<form>表单绑定submit事件，下面的代码没有预期的效果：
<html>
<head>
    <script>
        // 代码有误:
        $('#testForm).on('submit', function () {
            alert('submit!');
        });
    </script>
</head>
<body>
    <form id="testForm">
        ...
    </form>
</body>
因为JavaScript在此执行的时候，<form>尚未载入浏览器，所以$('#testForm)返回[]，并没有绑定事件到任何DOM上。
所以我们自己的初始化代码必须放到document对象的ready事件中，保证DOM已完成初始化：
<html>
<head>
    <script>
        $(document).on('ready', function () {
            $('#testForm).on('submit', function () {
                alert('submit!');
            });
        });
    </script>
</head>
<body>
    <form id="testForm">
        ...
    </form>
</body>
这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。
由于ready事件使用非常普遍，所以可以这样简化：
$(document).ready(function () {
    // on('submit', function)也可以简化:
    $('#testForm).submit(function () {
        alert('submit!');
    });
});
甚至还可以简化：
$(function () {
    // init...
});
上面的这种写法最为常见。如果你遇到$(function () {...})的形式，牢记这是document对象的ready事件处理函数。

完全可以反复绑定事件处理函数，它们会依次执行：
$(function () {
    console.log('init A...');
});
$(function () {
    console.log('init B...');
});
$(function () {
    console.log('init C...');
});
事件参数
有些事件，如mousemove和keypress，我们需要获取鼠标和按键的值，所有事件会传入Event对象作为参数，可以从Event对象获取信息
$(function(){
	$('#testMouseMoveDiv').mousemove(function(e){
		$('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY);
	});
});
取消绑定
一个已经被绑定的事件可以解除绑定，通过off('click',function)实现
function hello() {
    alert('hello!');
}

a.click(hello); // 绑定事件

// 10秒钟后解除绑定:
setTimeout(function () {
    a.off('click', hello);
}, 10000);
下面这种写法是没有效果的：
// 绑定事件:
a.click(function () {
    alert('hello!');
});

// 并没有解除绑定:
a.off('click', function () {
    alert('hello!');
});
这是因为两个匿名函数虽然长得一模一样，但是它们是两个不同的函数对象，off('click', function () {...})无法移除已绑定的第一个匿名函数。
为了实现移除效果，可以使用off('click')一次性移除已绑定的click事件的所有处理函数。
同理，无参数调用off()一次性移除已绑定的所有类型的事件处理函数。

事件触发条件
一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动：
var input = $('#test-input');
input.change(function () {
    console.log('changed...');
});
当用户在文本框中输入时，就会触发change事件。但是，如果用JavaScript代码去改动文本框的值，将不会触发change事件：
var input = $('#test-input');
input.val('change it!'); // 无法触发change事件
有些时候，我们希望用代码触发change事件，可以直接调用无参数的change()方法来触发该事件：
var input = $('#test-input');
input.val('change it!');
input.change(); // 触发change事件
input.change()相当于input.trigger('change')，它是trigger()方法的简写。
为什么我们希望手动触发一个事件呢？如果不这么做，很多时候，我们就得写两份一模一样的代码。

浏览器安全限制
在浏览器中，有些Javascript代码只有在用户触发下才能执行，例如window.open()函数 
$(function(){
	window.open('/');
}); //无法弹出，将被浏览器屏蔽
这些“敏感代码”只能由用户操作来触发：
var button1 = $('#testPopupButton1');
var button2 = $('#testPopupButton2');

function popupTestWindow() {
    window.open('/');
}

button1.click(function () {
    popupTestWindow();
});

button2.click(function () {
    // 不立刻执行popupTestWindow()，100毫秒后执行:
    setTimeout(popupTestWindow, 100);
});
当用户点击button1时，click事件被触发，由于popupTestWindow()在click事件处理函数内执行，这是浏览器
允许的，而button2的click事件并未立刻执行popupTestWindow()，延迟执行的popupTestWindow()将被浏览器拦截。

6.4 动画
用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。

但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。

使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！

让我们先来看看jQuery内置的几种动画样式：
show/hide
直接以无参数形式调用show()和hide(), 会显示和隐藏DOM元素，但是只要传递一个时间参数就变成了动画：
var div = $('#test-show-hide');
div.hide(3000);//3秒内逐渐消失，单位为毫秒
也可以使用slow，fast这些字符
var div = $('#test-show-hide');
div.show('slow'); // 在0.6秒钟内逐渐显示
toggle()方法则根据当前状态决定是show()还是hide()。
slideUp / slideDown
你可能已经看出来了，show()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的。
slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作：
var div = $('#test-slide');
div.slideUp(3000); // 在3秒钟内逐渐向上消失
fadeIn / fadeOut
fadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断设置DOM元素的opacity属性来实现，而fadeToggle()则根据元素是否可见来决定下一步动作：
var div = $('#test-fade');
div.fadeOut('slow'); // 在0.6秒内淡出
自定义动画
如果上述动画效果还不能满足你的要求，那就祭出最后大招：animate()，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值：
var div = $('#test-animate');
div.animate({
    opacity: 0.25,
    width: '256px',
    height: '256px'
}, 3000); // 在3秒钟内CSS过渡到设定值
animate()还可以再传入一个函数，当动画结束时，该函数将被调用：
var div = $('#test-animate');
div.animate({
    opacity: 0.25,
    width: '256px',
    height: '256px'
}, 3000, function () {
    console.log('动画已结束');
    // 恢复至初始状态:
    $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');
});
实际上这个回调函数参数对于基本动画也是适用的。
串行动画
jQuery的动画效果还可以串行执行，通过delay()方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单：
var div = $('#test-animates');
// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小
div.slideDown(2000)
   .delay(1000)
   .animate({
       width: '256px',
       height: '256px'
   }, 2000)
   .delay(1000)
   .animate({
       width: '128px',
       height: '128px'
   }, 2000);
}
因为动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作。简单地把动画封装在函数中是不够的。
为什么有的动画没有效果？
你可能会遇到，有的动画如slideUp()根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如height从100px逐渐变为0。但是很多不是block性质的DOM元素，对它们设置height根本就不起作用，所以动画也就没有效果。
此外，jQuery也没有实现对background-color的动画效果，用animate()设置background-color也没有效果。这种情况下可以使用CSS3的transition实现动画效果。

6.4 AJAX 

用JavaScript写AJAX前面已经介绍过了，主要问题就是不同浏览器需要写不同代码，并且状态和错误处理写起来很麻烦。
用jQuery的相关对象来处理AJAX，不但不需要考虑浏览器问题，代码也能大大简化。
jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求。ajax(url, settings)函数需要接收一个URL和一个可选的settings对象，常用的选项如下：

    async：是否异步执行AJAX请求，默认为true，千万不要指定为false；

    method：发送的Method，缺省为'GET'，可指定为'POST'、'PUT'等；

    contentType：发送POST请求的格式，默认值为'application/x-www-form-urlencoded; charset=UTF-8'，也可以指定为text/plain、application/json；

    data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式；

    headers：发送的额外的HTTP头，必须是一个object；

    dataType：接收的数据格式，可以指定为'html'、'xml'、'json'、'text'等，缺省情况下根据响应的Content-Type猜测。

下面的例子发送一个GET请求，并返回一个JSON格式的数据：
var jqxhr = $.ajax('/api/categories', {
    dataType: 'json'
});
// 请求已经发送了
不过，如何用回调函数处理返回的数据和出错时的响应呢？
还记得Promise对象吗？jQuery的jqXHR对象类似一个Promise对象，我们可以用链式写法来处理各种回调：
function ajaxLog(s) {
    var txt = $('#test-response-text');
    txt.val(txt.val() + '\n' + s);
}

$('#test-response-text').val('');
var jqxhr = $.ajax('/api/categories', {
    dataType: 'json'
}).done(function (data) {
    ajaxLog('成功, 收到的数据: ' + JSON.stringify(data));
}).fail(function (xhr, status) {
    ajaxLog('失败: ' + xhr.status + ', 原因: ' + status);
}).always(function () {
    ajaxLog('请求完成: 无论成功或失败都会调用');
});

get 
对常用的AJAX操作，jQuery提供了一些辅助方法。由于GET请求最常见，所以jQuery提供了get()方法，可以这么写：
var jqxhr = $.get('/path/to/resource', {
    name: 'Bob Lee',
    check: 1
});
第二个参数如果是object，jQuery自动把它变成query string然后加到URL后面，实际的URL是：
/path/to/resource?name=Bob%20Lee&check=1
post
post()和get()类似，但是传入的第二个参数默认被序列化为application/x-www-form-urlencoded：
var jqxhr = $.post('/path/to/resource', {
    name: 'Bob Lee',
    check: 1
});
实际构造的数据name=Bob%20Lee&check=1作为POST的body被发送。
getJSON
var jqxhr = $.getJSON('/path/to/resource', {
    name: 'Bob Lee',
    check: 1
}).done(function (data) {
    // data已经被解析为JSON对象了
});
安全限制
jQuery的AJAX完全封装的是JavaScript的AJAX操作，所以它的安全限制和前面讲的用JavaScript写AJAX完全一样。
如果需要使用JSONP，可以在ajax()中设置jsonp: 'callback'，让jQuery实现JSONP跨域加载数据。
关于跨域的设置请参考浏览器 - AJAX一节中CORS的设置。

6.5 扩展
我们可以扩展jQuery来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写jQuery插件。
编写jQuery插件
给jQuery对象绑定一个新方法是通过扩展$.fn对象实现的，来编写一个扩展highlight()
$.fn.highlight1 = function () {
    // this已绑定为当前jQuery对象:
    this.css('backgroundColor', '#fffceb').css('color', '#d85030');
    return this;
};
注意到函数内部的this在调用时被绑定为jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法。
对于如下的HTML结构：
<div id="test-highlight1">
    <p>什么是<span>jQuery</span></p>
    <p><span>jQuery</span>是目前最流行的<span>JavaScript</span>库。</p>
</div>
来高亮一下：
$('#test-highlight1 span').highlight1()；
细心的童鞋可能发现了，为什么最后要return this;？因为jQuery对象支持链式操作，我们自己写的扩展方法也要能继续链式下去：
但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办？
我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的highlight2()：
$.fn.highlight2 = function (options) {
    // 要考虑到各种情况:
    // options为undefined
    // options只有部分key
    var bgcolor = options && options.backgroundColor || '#fffceb';
    var color = options && options.color || '#d85030';
    this.css('backgroundColor', bgcolor).css('color', color);
    return this;
}；
对于如下结构
<div id="test-highlight2">
    <p>什么是<span>jQuery</span> <span>Plugin</span></p>
    <p>编写<span>jQuery</span> <span>Plugin</span>可以用来扩展<span>jQuery</span>的功能。</p>
</div>
高亮下
$('#test-highlight2 span').highlight2({
    backgroundColor: '#00a8e6',
    color: '#ffffff'
});
对于默认值的处理，我们用了一个简单的&&和||短路操作符，总能得到一个有效的值。
另一种方法是jQuery提供的辅助方法$.extend(target,obj1,obj2,...),把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后对象的值
var opts = $.extend({},{
	backgroundColor: '#00a8e6',
    color: '#ffffff'
},options);
紧接着用户对highlight2()提出了意见：每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的highlight2()？

也就是说，我们设定的默认值应该能允许用户修改。

那默认值放哪比较合适？放全局变量肯定不合适，最佳地点是$.fn.highlight2这个函数对象本身。

于是最终版的highlight()终于诞生了：
$.fn.highlight = function (options) {
    // 合并默认值和用户设定值:
    var opts = $.extend({}, $.fn.highlight.defaults, options);
    this.css('backgroundColor', opts.backgroundColor).css('color', opts.color);
    return this;
}

// 设定默认值:
$.fn.highlight.defaults = {
    color: '#d85030',
    backgroundColor: '#fff8de'
}
这次用户终于满意了。用户使用时，只需一次性设定默认值：
$.fn.highlight.defaults.color = '#fff';
$.fn.highlight.defaults.backgroundColor = '#000';
然后就可以非常简单地调用highlight()了。

对如下的HTML结构：
<!-- HTML结构 -->
<div id="test-highlight">
    <p>如何编写<span>jQuery</span> <span>Plugin</span></p>
    <p>编写<span>jQuery</span> <span>Plugin</span>，要设置<span>默认值</span>，并允许用户修改<span>默认值</span>，或者运行时传入<span>其他值</span>。</p>
</div>
$.fn.highlight.defaults.color = '#659f13';
$.fn.highlight.defaults.backgroundColor = '#f2fae3';

$('#test-highlight p:first-child span').highlight();

$('#test-highlight p:last-child span').highlight({
    color: '#dd1144'
});
最终，我们得出编写一个jQuery插件的原则：
    给$.fn绑定函数，实现插件的代码逻辑；
    插件函数最后要return this;以支持链式调用；
    插件函数要有默认值，绑定在$.fn.<pluginName>.defaults上；
    用户在调用时可传入设定值以便覆盖默认值。

针对特定元素的扩展
我们知道jQuery对象的有些方法只能作用在特定DOM元素上，比如submit()方法只能针对form。如果我们编写的扩展只能针对某些类型的DOM元素，应该怎么写？
还记得jQuery的选择器支持filter()方法来过滤吗？我们可以借助这个方法来实现针对特定元素的扩展。
举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做？
编写一个名为external的扩展：
$.fn.external = function () {
    // return返回的each()返回结果，支持链式调用:
    return this.filter('a').each(function () {
        // 注意: each()内部的回调函数的this绑定为DOM本身!
        var a = $(this);
        var url = a.attr('href');
        if (url && (url.indexOf('http://')===0 || url.indexOf('https://')===0)) {
            a.attr('href', '#0')
             .removeAttr('target')
             .append(' <i class="uk-icon-external-link"></i>')
             .click(function () {
                if(confirm('你确定要前往' + url + '？')) {
                    window.open(url);
                }
            });
        }
    });
}
对于结构：
<div id="test-external">
    <p>如何学习<a href="http://jquery.com">jQuery</a>？</p>
    <p>首先，你要学习<a href="/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000">JavaScript</a>，并了解基本的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML">HTML</a>。</p>
</div>
$('test-external a').external();


7. 错误处理
在执行JavaScript代码的时候，有些情况下会发生错误。
错误分两种，一种是程序写的逻辑不对，导致代码执行异常。例如：
var s = null;
var len = s.length; // TypeError：null变量没有length属性
对于这种错误，要修复程序。
一种是执行过程中，程序可能遇到无法预测的异常情况而报错，例如，网络连接中断，读取不存在的文件，没有操作权限等。
对于这种错误，我们需要处理它，并可能需要给用户反馈。
错误处理是程序设计时必须要考虑的问题。对于C这样贴近系统底层的语言，错误是通过错误码返回的：
int fd = open("/path/to/file", O_RDONLY);
if (fd == -1) {
    printf("Error when open file!");
} else {
    // TODO
}
通过错误码返回错误，就需要约定什么是正确的返回值，什么是错误的返回值。上面的open()函数约定返回-1表示错误。
这种用错误码表示错误在编写程序时十分不便。
因此，高级语言通常都提供了更抽象的错误处理逻辑try ... catch ... finally，JavaScript也不例外。
try...catch...finally
用其处理错误时，编写代码如下：
var r1, r2, s = null;
try {
    r1 = s.length; // 此处应产生错误
    r2 = 100; // 该语句不会执行
} catch (e) {
    console.log('出错了：' + e);
} finally {
    console.log('finally');
}
console.log('r1 = ' + r1); // r1应为undefined
console.log('r2 = ' + r2); // r2应为undefined
运行结果：
出错了：TypeError: s is null
finally
r1 = undefined
r2 = undefined
我们来分析一下使用try ... catch ... finally的执行流程。

当代码块被try { ... }包裹的时候，就表示这部分代码执行过程中可能会发生错误，一旦发生错误，就不再继续执行后续代码，
转而跳到catch块。catch (e) { ... }包裹的代码就是错误处理代码，变量e表示捕获到的错误。最后，无论有没有错误，finally一定会被执行。
所以，有错误发生时，执行流程像这样：

    先执行try { ... }的代码；
    执行到出错的语句时，后续语句不再继续执行，转而执行catch (e) { ... }代码；
    最后执行finally { ... }代码。

而没有错误发生时，执行流程像这样：

    先执行try { ... }的代码；
    因为没有出错，catch (e) { ... }代码不会被执行；
    最后执行finally { ... }代码。

最后请注意，catch和finally可以不必都出现。也就是说，try语句一共有三种形式：

完整的try ... catch ... finally：
try {
    ...
} catch (e) {
    ...
} finally {
    ...
}
只有try ... catch，没有finally：
try {
    ...
} catch (e) {
    ...
}
只有try ... finally，没有catch：
try {
    ...
} finally {
    ...
}

错误类型
JavaScript有一个标准的Error对象表示错误，还有从Error派生的TypeError、ReferenceError等错误对象。我们在处理错误时，可以通过catch(e)捕获的变量e访问错误对象：
try {
    ...
} catch (e) {
    if (e instanceof TypeError) {
        alert('Type error!');
    } else if (e instanceof Error) {
        alert(e.message);
    } else {
        alert('Error: ' + e);
    }
}
使用变量e是一个习惯用法，也可以以其他变量名命名，如catch(ex)。
抛出错误
程序也可以主动抛出一个错误，让执行流程直接跳转到catch块。抛出错误使用throw语句。
例如，下面的代码让用户输入一个数字，程序接收到的实际上是一个字符串，然后用parseInt()转换为整数。当用户输入不合法的时候，我们就抛出错误：
var r, n, s;
try {
    s = prompt('请输入一个数字');
    n = parseInt(s);
    if (isNaN(n)) {
        throw new Error('输入错误');
    }
    // 计算平方:
    r = n * n;
    console.log(n + ' * ' + n + ' = ' + r);
} catch (e) {
    console.log('出错了：' + e);
}
实际上，JavaScript允许抛出任意对象，包括数字、字符串。但是，最好还是抛出一个Error对象。
最后，当我们用catch捕获错误时，一定要编写错误处理语句，因为catch到错误却什么都不执行，就不知道程序执行过程中到底有没有发生错误。
处理错误时，请不要简单粗暴地用alert()把错误显示给用户。教程的代码使用alert()是为了便于演示。

7.1 错误传播
如果代码发生了错误，又没有被try ... catch捕获，那么，程序执行流程会跳转到哪呢？
function getLength(s) {
    return s.length;
}

function printLength() {
    console.log(getLength('abc')); // 3
    console.log(getLength(null)); // Error!
}

printLength();

如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。
所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽：
function main(s) {
    console.log('BEGIN main()');
    try {
        foo(s);
    } catch (e) {
        console.log('出错了：' + e);
    }
    console.log('END main()');
}

function foo(s) {
    console.log('BEGIN foo()');
    bar(s);
    console.log('END foo()');
}

function bar(s) {
    console.log('BEGIN bar()');
    console.log('length = ' + s.length);
    console.log('END bar()');
}

main(null);
当bar()函数传入参数null时，代码会报错，错误会向上抛给调用方foo()函数，foo()函数没有try ... catch语句，所以错误继续向上抛给调用方main()函数，main()函数有try ... catch语句，所以错误最终在main()函数被处理了。

7.2 错误处理
编写JavaScript代码时，我们要时刻牢记，JavaScript引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。
例如，setTimeout()函数可以传入回调函数，并在指定若干毫秒后执行：
function printTime() {
    console.log('It is time!');
}

setTimeout(printTime, 1000);
console.log('done');
上面的代码会先打印done，1秒后才会打印It is time!。
如果printTime()函数内部发生了错误，我们试图用try包裹setTimeout()是无效的：
function printTime() {
    throw new Error();
}

try {
    setTimeout(printTime, 1000);
    console.log('done');
} catch (e) {
    console.log('error');
}
原因就在于调用setTimeout()函数时，传入的printTime函数并未立刻执行！紧接着，JavaScript引擎会继续执行console.log('done');语句，而此时并没有错误发生。直到1秒钟后，执行printTime函数时才发生错误，但此时除了在printTime函数内部捕获错误外，外层代码并无法捕获。
所以，涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。
似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。
例如，针对以下的表单：
<form>
    <input id="x"> + <input id="y">
    <button id="calc" type="button">计算</button>
</form>

我们用下面的代码给button绑定click事件：
'use strict';

var $btn = $('#calc');

// 取消已绑定的事件:
$btn.off('click');
try {
    $btn.click(function () {
        var
            x = parseFloat($('#x').val()),
            y = parseFloat($('#y').val()),
            r;
        if (isNaN(x) || isNaN(y)) {
            throw new Error('输入有误');
        }
        r = x + y;
        alert('计算结果：' + r);
    });
} catch (e) {
    alert('输入有误！');
}



8. underscore
Javascript是函数式编程语言，支持高阶函数和闭包，可以写出很简洁的代码，例如Array的map()和filter()方法：
'use strict';
var a1 = [1, 4, 9, 16];
var a2 = a1.map(Math.sqrt); // [1, 2, 3, 4]
var a3 = a2.filter((x) => { return x % 2 === 0; }); // [2, 4]
现在问题来了，Array有map()和filter()方法，可是Object没有这些方法。此外，低版本的浏览器例如IE6～8也没有这些方法，怎么办？
方法一，自己把这些方法添加到Array.prototype中，然后给Object.prototype也加上mapObject()等类似的方法。
方法二，直接找一个成熟可靠的第三方开源库，使用统一的函数来实现map()、filter()这些操作。
我们采用方法二，选择的第三方库就是underscore。
正如jQuery统一了不同浏览器之间的DOM操作的差异，让我们可以简单地对DOM进行操作，underscore则提供了一套完善的函数式编程的接口，让我们更方便地在JavaScript中实现函数式编程。
jQuery在加载时，会把自身绑定到唯一的全局变量$上，underscore与其类似，会把自身绑定到唯一的全局变量_上，这也是为啥它的名字叫underscore的原因。
用underscore实现map()操作如下：
'use strict';
_.map([1,2,3],(x)=>x*x);
uderscore还能作用于对象；
'use strict';
_.map({ a: 1, b: 2, c: 3 }, (v, k) => k + '=' + v); // ['a=1', 'b=2', 'c=3']

8.1 collections
underscore为集合类对象提供了一致的接口，集合类指的是Array和Object，不包括；Map和Set
map和filter
和Array的map()与filter()类似，但是underscore的map()和filter()可以作用于Object。当作用于Object时，传入的函数为function (value, key)，第一个参数接收value，第二个参数接收key：
'use strict';

var obj = {
    name: 'bob',
    school: 'No.1 middle school',
    address: 'xueyuan road'
};
var upper = _.map(obj, function (value, key) {
    return value + "*";
});
你也许会想，为啥对Object作map()操作的返回结果是Array？应该是Object才合理啊！把_.map换成_.mapObject再试试。
every和some
当集合的所有元素都满足条件时，_.every()函数返回true，当集合的至少一个元素满足条件时，_.some()函数返回true：
'use strict';
// 所有元素都大于0？
_.every([1, 4, 7, -3, -9], (x) => x > 0); // false
// 至少一个元素大于0？
_.some([1, 4, 7, -3, -9], (x) => x > 0); // true
max和min
这两个函数直接返回集合中最大和最小的数：
'use strict';
var arr = [3, 5, 7, 9];
_.max(arr); // 9
_.min(arr); // 3

// 空集合会返回-Infinity和Infinity，所以要先判断集合不为空：
注意，如果集合是Object，max()和min()只作用于value，忽略掉key：
_.max({ a: 1, b: 2, c: 3 }); // 3
groupBy
groupBy()把集合的元素按照key归类，key由传入的函数返回：
'use strict';

var scores = [20, 81, 75, 40, 91, 59, 77, 66, 72, 88, 99];
var groups = _.groupBy(scores, function (x) {
    if (x < 60) {
        return 'C';
    } else if (x < 80) {
        return 'B';
    } else {
        return 'A';
    }
});
// 结果:
// {
//   A: [81, 91, 88, 99],
//   B: [75, 77, 66, 72],
//   C: [20, 40, 59]
// }
shuffle和sample
shuffle()用洗牌算法随机打乱一个集合：
'use strict';
// 注意每次结果都不一样：
_.shuffle([1, 2, 3, 4, 5, 6]); // [3, 5, 4, 6, 2, 1]
sample()则是随机选择一个或多个元素：
'use strict';
// 注意每次结果都不一样：
// 随机选1个：
_.sample([1, 2, 3, 4, 5, 6]); // 2
// 随机选3个：
_.sample([1, 2, 3, 4, 5, 6], 3); // [6, 1, 4]
更多underscore文档请参考：http://underscorejs.org/#collections

8.2 Arrays
underscore为Array提供了许多工具类方法，可以更方便快捷地操作Array。
first和last
顾名思义，这两个函数分别取第一个和最后一个元素：
'use strict';
var arr = [2, 4, 6, 8];
_.first(arr); // 2
_.last(arr); // 8
flatten扁平化
flatten()接收一个Array，无论这个Array里面嵌套了多少个Array，flatten()最后都把它们变成一个一维数组：
_.flatten([1, [2], [3, [[4], [5]]]]); // [1, 2, 3, 4, 5]
zip和unzip
zip()把两个或多个数组的所有元素按索引对齐，然后按索引合并成新数组。例如，你有一个Array保存了名字，另一个Array保存了分数，现在，要把名字和分数给对上，用zip()轻松实现：
var names = ['Adam', 'Lisa', 'Bart'];
var scores = [85, 92, 59];
_.zip(names, scores);
// [['Adam', 85], ['Lisa', 92], ['Bart', 59]]
unzip()则是反过来：
var namesAndScores = [['Adam', 85], ['Lisa', 92], ['Bart', 59]];
_.unzip(namesAndScores);
// [['Adam', 'Lisa', 'Bart'], [85, 92, 59]]
object
有时候你会想，与其用zip()，为啥不把名字和分数直接对应成Object呢？别急，object()函数就是干这个的：
var names = ['Adam', 'Lisa', 'Bart'];
var scores = [85, 92, 59];
_.object(names, scores);
// {Adam: 85, Lisa: 92, Bart: 59}
注意_.object()是一个函数，不是JavaScript的Object对象。
range
range()让你快速生成一个序列，不再需要用for循环实现了：
/ 从0开始小于10:
_.range(10); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

// 从1开始小于11：
_.range(1, 11); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// 从0开始小于30，步长5:
_.range(0, 30, 5); // [0, 5, 10, 15, 20, 25]

// 从0开始大于-10，步长-1:
_.range(0, -10, -1); // [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]

8.3 functions
underscore提供了大量Javascript本身没有的高阶函数
bind
bind()有什么用，先看一个错误用法：
var s = ' hello ';
s.trim();
var fn = s.trim;
fn();
结果为：
// Uncaught TypeError: String.prototype.trim called on null or undefined
如果你想用fn()取代s.trim()，按照上面的做法是不行的，因为直接调用fn()传入的this指针是undefined，必须这么用：
'use strict';
var s = ' Hello  ';
var fn = s.trim;
// 调用call并传入s对象作为this:
fn.call(s)
// 输出Hello
这样搞多麻烦！还不如直接用s.trim()。但是，bind()可以帮我们把s对象直接绑定在fn()的this指针上，以后调用fn()就可以直接正常调用了：
var s = ' Hello ';
var fn = _.bind(s.trim,s);
fn();
结论：当用一个变量fn指向一个对象的方法时，直接调用fn()是不行的，因为丢失了this对象的引用。用bind可以修复这个问题。
partial
partial()就是为一个函数创建偏函数。偏函数是什么东东？看例子：
假设我们要计算xy，这时只需要调用Math.pow(x, y)就可以了。假设我们经常计算2y，每次都写
Math.pow(2, y)就比较麻烦，如果创建一个新的函数能直接这样写pow2N(y)就好了，这个新函数pow2N(y)就是根据Math.pow(x, y)
创建出来的偏函数，它固定住了原函数的第一个参数（始终为2）：
var pow2N=_.partial(Math.pow,2);
pow2N(3);
如果我们不想固定第一个参数，想固定第二个参数怎么办？比如，希望创建一个偏函数cube(x)，计算x3，可以用_作占位符，固定住第二个参数：
var cube = _.partial(Math.pow,_,3);
cube(3);
可见，创建偏函数的目的是将原函数的某些参数固定住，可以降低新函数调用的难度。
memoize
如果一个函数调用开销很大，我们就可能希望能把结果缓存下来，以便后续调用时直接获得结果。举个例子，计算阶乘就比较耗时：
function factorial(n) {
    console.log('start calculate ' + n + '!...');
    var s = 1, i = n;
    while (i > 1) {
        s = s * i;
        i --;
    }
    console.log(n + '! = ' + s);
    return s;
}

factorial(10); // 3628800
// 注意控制台输出:
// start calculate 10!...
// 10! = 3628800
用memoize()就可以自动缓存函数计算的结果：
var factorial = _.memoize(function(n) {
    console.log('start calculate ' + n + '!...');
    var s = 1, i = n;
    while (i > 1) {
        s = s * i;
        i --;
    }
    console.log(n + '! = ' + s);
    return s;
});

// 第一次调用:
factorial(10); // 3628800
// 注意控制台输出:
// start calculate 10!...
// 10! = 3628800

// 第二次调用:
factorial(10); // 3628800
// 控制台没有输出
对于相同的调用，比如连续两次调用factorial(10)，第二次调用并没有计算，而是直接返回上次计算后缓存的结果。不过，当你计算factorial(9)的时候，仍然会重新计算。
可以对factorial()进行改进，让其递归调用：

var factorial = _.memoize(function(n) {
    console.log('start calculate ' + n + '!...');
    if (n < 2) {
        return 1;
    }
    return n * factorial(n - 1);
});

factorial(10); // 3628800
// 输出结果说明factorial(1)~factorial(10)都已经缓存了:
// start calculate 10!...
// start calculate 9!...
// start calculate 8!...
// start calculate 7!...
// start calculate 6!...
// start calculate 5!...
// start calculate 4!...
// start calculate 3!...
// start calculate 2!...
// start calculate 1!...

factorial(9); // 362880
// console无输出

once
顾名思义，once()保证某个函数执行且仅执行一次。如果你有一个方法叫register()，用户在页面上点两个按钮的任何一个都可以执行的话，就可以用once()保证函数仅调用一次，无论用户点击多少次：
var register =_.once(function () {
    alert('Register ok!');
});
只出现一次Register ok！
 delay
 delay()可以让一个函数延迟执行，效果和setTimeout()是一样的，但是代码明显简单了：
 _.delay(alert,2000);
 如果要延迟调用的函数有参数，把参数也传进去：
 var log = _.bind(console.log, console);
_.delay(log, 2000, 'Hello,', 'world!');

8.4 Objects
和Array类似，underscore也提供了大量针对Object的函数。
keys和allKeys
keys()可以非常方便地返回一个object自身所有的key，但不包含从原型链继承下来的：
function Student(name, age) {
    this.name = name;
    this.age = age;
}

var xiaoming = new Student('小明', 20);
_.keys(xiaoming); // ['name', 'age']
allKeys()除了object自身的key，还包含从原型链继承下来的：
function Student(name, age) {
    this.name = name;
    this.age = age;
}
Student.prototype.school = 'No.1 Middle School';
var xiaoming = new Student('小明', 20);
_.allKeys(xiaoming); // ['name', 'age', 'school']
values
和keys()类似，values()返回object自身但不包含原型链继承的所有值：
var obj = {
    name: '小明',
    age: 20
};

_.values(obj); // ['小明', 20]
注意，没有allValues()，原因我也不知道。
mapObject
mapObject()就是针对object的map版本：
var obj = { a: 1, b: 2, c: 3 };
// 注意传入的函数签名，value在前，key在后:
_.mapObject(obj, (v, k) => 100 + v); // { a: 101, b: 102, c: 103 },返回一个对象，仅改变value值
invert
invert()把object的每个key-value来个交换，key变成value，value变成key：
var obj = {
    Adam: 90,
    Lisa: 85,
    Bart: 59
};
_.invert(obj); // { '59': 'Bart', '85': 'Lisa', '90': 'Adam' }
extend和extendOwn
extend()把多个object的key-value合并到第一个object并返回：
var a = {name: 'Bob', age: 20};
_.extend(a, {age: 15}, {age: 88, city: 'Beijing'}); // {name: 'Bob', age: 88, city: 'Beijing'}
// 变量a的内容也改变了：
a; // {name: 'Bob', age: 88, city: 'Beijing'}
注意：如果有相同的key，后面的object的value将覆盖前面的object的value。
extendOwn()和extend()类似，但获取属性时忽略从原型链继承下来的属性
clone
如果我们要复制一个object对象，就可以用clone()方法，它会把原有对象的所有属性都复制到新的对象中：
'use strict';
var source = {
    name: '小明',
    age: 20,
    skills: ['JavaScript', 'CSS', 'HTML']
};
var copied = _.clone(source);
console.log(JSON.stringify(copied, null, '  '));
注意，clone()是“浅复制”。所谓“浅复制”就是说，两个对象相同的key所引用的value其实是同一对象：
source.skills === copied.skills; // true
也就是说，修改source.skills会影响copied.skills。
isEqual
isEqual()对两个object进行深度比较，如果内容完全相同，则返回true：
var o1 = { name: 'Bob', skills: { Java: 90, JavaScript: 99 }};
var o2 = { name: 'Bob', skills: { JavaScript: 99, Java: 90 }};

o1 === o2; // false
_.isEqual(o1, o2); // true
isEqual()其实对Array也可以比较：
var o1 = ['Bob', { skills: ['Java', 'JavaScript'] }];
var o2 = ['Bob', { skills: ['Java', 'JavaScript'] }];

o1 === o2; // false
_.isEqual(o1, o2); // true

8.5 chainig
还记得jQuery支持链式调用吗？
$('a').attr('target', '_blank')
      .append(' <i class="uk-icon-external-link"></i>')
      .click(function () {});
如果我们有一组操作，用underscore提供的函数，写出来像这样：
_.filter(_.map([1, 4, 9, 16, 25], Math.sqrt), x => x % 2 === 1);
// [1, 3, 5]
我们可以写成链式调用，使用chain()函数
var r = _.chain([1, 4, 9, 16, 25])
         .map(Math.sqrt)
         .filter(x => x % 2 === 1)
         .value();
因为每一步返回的都是包装对象，所以最后一步的结果需要调用value()获得最终结果。

9. Node.js(后端开发）
在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。
Node.js的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。
其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。

9.1 安装Node.js和npm
Node.js最新版本是7.6x，先从官网https://nodejs.org/en/下载对应平台的安装程序，国内镜像https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fnodejs
windows安装时务必选择全部组件，包括勾选Add to Path。安装完后，在windows下打开命令行输入node -v，安装正常会显示版本号
继续在命令行输入node便会进入Node.js的交互环境，连续按两次Ctrl+C退出。Mac或Linux在终端输入node -v.如果版本号小于7.6.0，需重新安装新版本。
npm
npm是什么东东？npm其实是Node.js的包管理工具（package manager）。
为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，
非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。
更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦
又容易出错。讲了这么多，npm究竟在哪？其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入npm -v，应该看到类似的输出：
C:\>npm -v
4.1.2

9.2 第一个Node程序
代码要在Node环境中执行，因此需要用一个文本编辑器来编辑保存Javascript代码，推荐文本编辑器：http://www.sublimetext.com/，注意用UTF-8格式保存
第一行总是写上'use strict';是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。
然后，选择一个目录，例如C:\Workspace，把文件保存为hello.js，就可以打开命令行窗口，把当前目录切换到hello.js所在目录，然后输入以下命令运行这个程序了：
C:\Workspace>node hello.js
Hello, world.
文件名只能是英文字母、数字和下划线的组合。如果当前目录下没有hello.js这个文件，运行node hello.js就会报错：
命令模式和Node交互模式
类似C：\>是windows提供的 命令模式，执行node可进入Node交互模式，也可以执行一个.js文件；>是Node交互环境，此环境Javascript代码
会立即执行，此外，在命令行模式运行.js文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。
这是正常的。想要输出结果，必须自己用console.log()打印出来。
使用严格模式
如果在JavaScript文件开头写上'use strict';，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上'use strict';很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：
node --use_strict calc.js

9.3 搭建Node开发环境
使用文本编辑器来开发Node程序，最大的缺点是效率太低，运行Node程序还需要在命令行单独敲命令。如果还需要调试程序，就更加麻烦了。
所以我们需要一个IDE集成开发环境，Visual Studio Code由微软出品，但它不是那个大块头的Visual Studio，它是一个精简版的迷你Visual Studio，
并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用，官网https://code.visualstudio.com/，国内镜像https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fvscode
运行和调试JavaScript
VS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。此外，VS Code在工程目录下还需要一个.vscode的配置目录，里面存放里VS Code需要的配置文件。
假设我们在C:\Work\目录下创建了一个hello目录作为工程目录，并编写了一个hello.js文件，则该工程目录的结构如下：
hello/ <-- workspace dir
|
+- hello.js <-- JavaScript file
|
+- .vscode/  <-- VS Code config
   |
   +- launch.json <-- VS Code config file for JavaScript
可以用VS Code快速创建launch.json，然后修改如下：
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Run hello.js",
            "type": "node",
            "request": "launch",
            "program": "${workspaceRoot}/hello.js",
            "stopOnEntry": false,
            "args": [],
            "cwd": "${workspaceRoot}",
            "preLaunchTask": null,
            "runtimeExecutable": null,
            "runtimeArgs": [
                "--nolazy"
            ],
            "env": {
                "NODE_ENV": "development"
            },
            "externalConsole": false,
            "sourceMaps": false,
            "outDir": null
        }
    ]
}
有了配置文件，即可使用VS Code调试JavaScript。视频演示https://www.bilibili.com/video/av5827351/

9.4 模块
Node环境中，一个.js文件就称之为一个模块（module）。在上一节，我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。
我们把hello.js改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数：
'use strict';
var s = 'Hello';
function greet(name) {
	console.log(s+','+name+'!');
}
module.exports=greet;
函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。
问题是其他模块怎么使用hello模块的这个greet函数呢？我们再编写一个main.js文件，调用hello模块的greet函数：
'use strict';
var greet = require('./hello');
var s = 'Michael';
greet(s);
注意到引入hello模块用Node提供的require函数：
引入的模块作为变量保存在greet变量中，那greet变量到底是什么东西？其实变量greet就是在hello.js中我们用module.exports = greet;输出的greet函数。所以，main.js就成功地引用了hello.js模块中定义的greet()函数，接下来就可以直接使用它了。
在使用require()引入模块的时候，请注意模块的相对路径。因为main.js和hello.js位于同一个目录，所以我们用了当前目录.：
如果只写模块名，则Node会依次在内置模块、全局模块和当前模块下查找hello.js,可能会得到如下的错误：
module.js
    throw err;
          ^
Error: Cannot find module 'hello'
    at Function.Module._resolveFilename
    at Function.Module._load
    ...
    at Function.Module._load
    at Function.Module.runMain
	遇到这个错误，你要检查：
    模块名是否写对了；
    模块文件是否存在；
    相对路径是否写对了
	
commonJS规范
这种模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，hello.js和main.js都申明了全局变量var s = 'xxx'，但互不影响。
一个模块想要对外暴露变量（函数也是变量），可以用module.exports = variable;，一个模块要引用其他模块暴露的变量，用var ref = require('module_name');就拿到了引用模块的变量。

深入了解模块原理：
当我们编写JavaScript代码时，我们可以申明全局变量： var s = 'global';
在浏览器中，大量使用全局变量可不好。如果你在a.js中使用了全局变量s，那么，在b.js中也使用全局变量s，将造成冲突，b.js中对s赋值会改变a.js的运行逻辑。
也就是说，JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名那Node.js是如何实现这一点的？
其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。
请注意我们编写的hello.js代码是这样的：
var s = 'Hello';
var name = 'world';
console.log(s + ' ' + name + '!');
Node.js加载了hello.js后，它可以把代码包装一下，变成这样执行：
(function () {
    // 读取的hello.js代码:
    var s = 'Hello';
    var name = 'world';

    console.log(s + ' ' + name + '!');
    // hello.js代码结束
})();
这样一来，原来的全局变量s现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义的“全局”变量s也互不干扰。
所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。但是，模块的输出module.exports怎么实现？
这个也很容易实现，Node可以先准备一个对象module：
// 准备module对象:
var module = {
    id: 'hello',
    exports: {}
};
var load = function (module) {
    // 读取的hello.js代码:
    function greet(name) {
        console.log('Hello, ' + name + '!');
    }

    module.exports = greet;
    // hello.js代码结束
    return module.exports;
};
var exported = load(module);
// 保存module:
save(module, exported);
可见，变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在hello.js中可以直接使用变量module原因就在于它实际上是函数的一个参数：
通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。
由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出：
var greet = require('./hello');
module.exports vs exports
有两种方法可以在一个模块中输出变量：
方法一：对module.exports赋值：

function hello() {
    console.log('Hello, world!');
}

function greet(name) {
    console.log('Hello, ' + name + '!');
}

module.exports = {
    hello: hello,
    greet: greet
};
方法二：直接使用exports：
function hello() {
    console.log('Hello, world!');
}

function greet(name) {
    console.log('Hello, ' + name + '!');
}

function hello() {
    console.log('Hello, world!');
}

exports.hello = hello;
exports.greet = greet;
但是你不可以直接对exports赋值：
// 代码可以执行，但是模块并没有输出任何变量:
exports = {
    hello: hello,
    greet: greet
};
如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：
首先，Node会把整个待加载的hello.js文件放入一个包装函数load中执行。在执行这个load()函数前，Node准备好了module变量：
var module = {
    id: 'hello',
    exports: {}
};
load()函数最终返回module.exports：
var load = function (exports, module) {
    // hello.js的文件内容
    ...
    // load函数返回:
    return module.exports;
};

var exported = load(module.exports, module);
也就是说，默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，并且初始化为空对象{}，于是，我们可以写：
exports.foo = function () { return 'foo'; };
exports.bar = function () { return 'bar'; };
也可以写：
odule.exports.foo = function () { return 'foo'; };
module.exports.bar = function () { return 'bar'; };
换句话说，Node默认给你准备了一个空对象{}，这样你可以直接往里面加东西。
但是，如果我们要输出的是一个函数或数组，那么，只能给module.exports赋值：
module.exports = function () { return 'foo'; };
给exports赋值是无效的，因为赋值后，module.exports仍然是空对象{}。
如果要输出一个键值对象{}，可以利用exports这个已存在的空对象{}，并继续在上面添加新的键值；
如果要输出一个函数或数组，必须直接对module.exports对象赋值。
所以我们可以得出结论：直接对module.exports赋值，可以应对任何情况：
module.exports = {
    foo: function () { return 'foo'; }
};
最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，这样，你只需要记忆一种方法。


9.5 基本模块
因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，
处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。
global
在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫window对象。而在Node.js环境中，也有唯一的全局对象，但不叫window，而叫global，这个对象的
属性和方法也和浏览器环境的window不同。进入Node.js交互环境，可以直接输入：
> global.console
Console {
  log: [Function: bound ],
  info: [Function: bound ],
  warn: [Function: bound ],
  error: [Function: bound ],
  dir: [Function: bound ],
  time: [Function: bound ],
  timeEnd: [Function: bound ],
  trace: [Function: bound trace],
  assert: [Function: bound ],
  Console: [Function: Console] }
  
  process
  process也是Node.js提供的一个对象，它代表当前Node.js进程。通过process对象可以拿到许多有用信息：
  > process === global.process;
true
> process.version;
'v5.2.0'
> process.platform;
'darwin'
> process.arch;
'x64'
> process.cwd(); //返回当前工作目录
'/Users/michael'
> process.chdir('/private/tmp'); // 切换当前工作目录
undefined
> process.cwd();
'/private/tmp'
JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。
如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick()：
 // process.nextTick()将在下一轮事件循环中调用:
process.nextTick(function () {
    console.log('nextTick callback!');
});
console.log('nextTick was set!');
用Node执行上面的代码node test.js，你会看到，打印输出是：
nextTick was set!
nextTick callback!
这说明传入process.nextTick()的函数不是立刻执行，而是要等到下一次事件循环。
Node.js进程本身的事件就由process对象来处理。如果我们响应exit事件，就可以在程序即将退出时执行某个回调函数：
/ 程序即将退出时的回调函数:
process.on('exit', function (code) {
    console.log('about to exit with code: ' + code);
});
判断JavaScript执行环境
有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：
if (typeof(window) === 'undefined') {
    console.log('node.js');
} else {
    console.log('browser');
}

9.51 fs
Node.js内置的fs模块是文件系统模块，负责读写文件，和其他JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。
回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的getJSON()操作：
$.getJSON('http://example.com/ajax', function (data) {
    console.log('IO结果返回后执行...');
});
console.log('不等待IO结果直接执行后续代码...');
而同步的IO操作则需要等待函数返回：
// 根据网络耗时，函数将执行几十毫秒~几秒不等:
var data = getJSONSync('http://example.com/ajax');
同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦
异步读文件
按照JavaScript的标准，异步读取一个文本文件的代码如下：
'use strict';
var fs =require('fs');
fs.readFile('sample.txt','utf-8',function(err,data){
	if(err) {
		console.log(err);
	}else{
		console.log(data);
	}
});
请注意，sample.txt文件必须在当前目录下，且文件编码为utf-8。
异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。
由于err是否为null就是判断是否出错的标志，所以通常的判断逻辑总是：
if (err) {
    // 出错了
} else {
    // 正常
}
读取二进制文件而非文本文件，下面演示如何读取一个图片文件：
'use strict';
var fs = require('fs');
fs.readFile('sample.png',function(err,data) {
	if (err) {
		console.log(err);
	}else {
		console.log(data);
		console.log(data.length + ' bytes');
	}
});
当读取二进制文件时，不传入文件编码时，回调函数的data参数返回一个Buffer对象，Node.js中Buffer对象是一个包含零个或多个字节的数组，与Array不同。
Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String：
var text = data.tostring('utf-8);
console.log(text);
将string 转换成Buffer：
var buf = Buffer.from(text, 'utf-8');
console.log(buf);

同步读文件
除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。
用fs模块同步读取一个文本文件的代码如下：
'use strict';
var fs = require('fs');
var data = fs.readFileSync('sample.txt', 'utf-8');
console.log(data);
可见，原异步调用的回调函数的data被函数直接返回，函数名需要改为readFileSync，其它参数不变。
如果同步读取文件发生错误，则需要用try...catch捕获该错误：
try {
    var data = fs.readFileSync('sample.txt', 'utf-8');
    console.log(data);
} catch (err) {
    // 出错了
}

写文件
将数据写入文件是通过fs.writeFile()实现的：
'use strict';

var fs = require('fs');

var data = 'Hello, Node.js';
fs.writeFile('output.txt', data, function (err) {
    if (err) {
        console.log(err);
    } else {
        console.log('ok.');
    }
});
writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。
和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()：
'use strict';
var fs = require('fs');
var data = 'Hello, Node.js';
fs.writeFileSync('output.txt', data);
 
 stat
 如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息：
 'use strict';

var fs = require('fs');

fs.stat('sample.txt', function (err, stat) {
    if (err) {
        console.log(err);
    } else {
        // 是否是文件:
        console.log('isFile: ' + stat.isFile());
        // 是否是目录:
        console.log('isDirectory: ' + stat.isDirectory());
        if (stat.isFile()) {
            // 文件大小:
            console.log('size: ' + stat.size);
            // 创建时间, Date对象:
            console.log('birth time: ' + stat.birthtime);
            // 修改时间, Date对象:
            console.log('modified time: ' + stat.mtime);
        }
    }
});
运行结果：
isFile: true
isDirectory: false
size: 181
birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)
modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST)
stat()也有一个对应的同步函数statSync()，请试着改写上述异步代码为同步代码。

异步还是同步
异步还是同步

在fs模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？
由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。
服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。
 
 9.52 stream
 stream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。
什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。
如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。
有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。
在Node.js中，流也是一个对象，我们只需要响应流的事就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。
下面是一个从文件流读取文本内容的示例：
'use strict';
var fs =require('fs');
var rs =fs.createReadStream('sample.txt', 'utf-8');
rs.on('data',function(chunk){
	console.log('DATA:');
	console.log(chunk);
});
rs.on('end',function(){
	console.log('END');
});
rs.on('error',function(err){
	console.log('ERROR:' +err);
});
要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。
要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束：
'use strict';
var fs = require('fs');
var ws1 = fs.createWriteStream('output.txt', 'utf-8');
ws1.write('写入文本数据’);
ws1.write('END.');
ws1.end();

var ws2 = fs.createWriteStream('output2.txt');
ws2.write(new Buffer('使用Stream写入二进制数据...\n', 'utf-8'));
ws2.write(new Buffer('END.', 'utf-8'));
ws2.end();
所有课读取数据的流都继承自stream.Readable,所有可以写入的流都继承自stream.Writable。

pipe
就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。

在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。
让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：
'use strict';
var fs = require('fs');
var rs = fs.createReadStream('sample.txt');
var ws = fs.createWriteStream('copied.txt');
rs.pipe(ws);
默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数：
readable.pipe(writable, { end: false });

9.53 http
HTTP协议
http协议是浏览器与服务器之间传输数据的规定。具体介绍看后面。
HTTP服务器
要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。
request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息；
response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。
用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!：
'use strict';

// 导入http模块:
var http = require('http');

// 创建http server，并传入回调函数:
var server = http.createServer(function (request, response) {
    // 回调函数接收request和response对象,
    // 获得HTTP请求的method和url:
    console.log(request.method + ': ' + request.url);
    // 将HTTP响应200写入response, 同时设置Content-Type: text/html:
    response.writeHead(200, {'Content-Type': 'text/html'});
    // 将HTTP响应的HTML内容写入response:
    response.end('<h1>Hello world!</h1>');
});

// 让服务器监听8080端口:
server.listen(8080);
console.log('Server is running at http://127.0.0.1:8080/');
在命令提示符下运行该程序，可以看到以下输出：
$ node hello.js 
Server is running at http://127.0.0.1:8080/
不要关闭命令提示符，直接打开浏览器输入http://localhost:8080，即可看到服务器响应的内容：
同时，在命令提示符窗口，可以看到程序打印的请求信息：
GET: /
GET: /favicon.ico
文件服务器
让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。
解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象：
'use strict';
var url = require('url');
console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));
Url {
  protocol: 'http:',
  slashes: true,
  auth: 'user:pass',
  host: 'host.com:8080',
  port: '8080',
  hostname: 'host.com',
  hash: '#hash',
  search: '?query=string',
  query: 'query=string',
  pathname: '/path/to/file',
  path: '/path/to/file?query=string',
  href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' }
处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：
'use strict';

var path = require('path');

// 解析当前目录:
var workDir = path.resolve('.'); // '/Users/michael'

// 组合完整的文件路径:当前目录+'pub'+'index.html':
var filePath = path.join(workDir, 'pub', 'index.html');
// '/Users/michael/pub/index.html'
使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于C:\Users\michael\static\index.html，这样，我们就不关心怎么拼接路径了。
最后，我们实现一个文件服务器file_server.js：
'use strict';

var
    fs = require('fs'),
    url = require('url'),
    path = require('path'),
    http = require('http');

// 从命令行参数获取root目录，默认是当前目录:
var root = path.resolve(process.argv[2] || '.');

console.log('Static root dir: ' + root);

// 创建服务器:
var server = http.createServer(function (request, response) {
    // 获得URL的path，类似 '/css/bootstrap.css':
    var pathname = url.parse(request.url).pathname;
    // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':
    var filepath = path.join(root, pathname);
    // 获取文件状态:
    fs.stat(filepath, function (err, stats) {
        if (!err && stats.isFile()) {
            // 没有出错并且文件存在:
            console.log('200 ' + request.url);
            // 发送200响应:
            response.writeHead(200);
            // 将文件流导向response:
            fs.createReadStream(filepath).pipe(response);
        } else {
            // 出错了或者文件不存在:
            console.log('404 ' + request.url);
            // 发送404响应:
            response.writeHead(404);
            response.end('404 Not Found');
        }
    });
});

server.listen(8080);

console.log('Server is running at http://127.0.0.1:8080/');
没有必要手动读取文件内容。由于response对象本身是一个Writable Stream，直接用pipe()方法就实现了自动读取文件内容并输出到HTTP响应。

在命令行运行node file_server.js /path/to/dir，把/path/to/dir改成你本地的一个有效的目录，然后在浏览器中输入http://localhost:8080/index.html：
只要当前目录下存在文件index.html，服务器就可以把文件内容发送给浏览器。观察控制台输出：
200 /index.html
200 /css/uikit.min.css
200 /js/jquery.min.js
200 /fonts/fontawesome-webfont.woff2
第一个请求是浏览器请求index.html页面，后续请求是浏览器解析HTML后发送的其它资源请求。
在浏览器输入http://localhost:8080/时，会返回404，原因是程序识别出HTTP请求的不是文件，而是目录。请修改file_server.js，如果遇到请求的路径是目录，则自动在目录下依次搜索index.html、default.html，如果找到了，就返回HTML文件的内容。
 
 9.54 crypto
 crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。
 MD5和SHA1
 MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：
 const crypto = require('crypto');
 const hash = cypto.createHash('md5');
 // 可任意多次调用update();
 hash.update('hello, world!);
 hash.update('hello, nodejs!');
 console.log(hash.digest('hex'));// 7e1977739c748beac0c0fd14fd26a544
 update()方法默认字符串编码为UTF-8,也可以传入Buffer。
 如果要计算SHA1，只需要把'md5'改成'sha1'，就可以得到SHA1的结果1f32b9c9932c02227819a4151feed43e131aca40。
还可以使用更安全的sha256和sha512。
 Hmac
 Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：
 const crypto =require('crypto');
 const hmac =crypto.createHmac('sha256', 'secret-key');
 hmac.update('Hello, world!');
 hmac.update('Hello, nodejs!');
 console.log(hmac.digest('hex'));// 80f7e22570.
 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。
 
 AES
 AES是一种常用的对称加密算法，加密解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：
 const crypto = require('crypto');

function aesEncrypt(data, key) {
    const cipher = crypto.createCipher('aes192', key);
    var crypted = cipher.update(data, 'utf8', 'hex');
    crypted += cipher.final('hex');
    return crypted;
}

function aesDecrypt(encrypted, key) {
    const decipher = crypto.createDecipher('aes192', key);
    var decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

var data = 'Hello, this is a secret message!';
var key = 'Password!';
var encrypted = aesEncrypt(data, key);
var decrypted = aesDecrypt(encrypted, key);

console.log('Plain text: ' + data);
console.log('Encrypted text: ' + encrypted);
console.log('Decrypted text: ' + decrypted);
结果如下：
Plain text: Hello, this is a secret message!
Encrypted text: 8a944d97bdabc157a5b7a40cb180e7...
Decrypted text: Hello, this is a secret message!
可以看出，加密后的字符串通过解密又得到了原始内容。

注意到AES有很多不同的算法，如aes192，aes-128-ecb，aes-256-cbc等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Nodejs全部都支持，
但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，字符串密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。
