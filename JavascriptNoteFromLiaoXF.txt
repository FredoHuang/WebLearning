廖雪峰Javascript教程学习笔记
一、快速入门
Javascript代码可以直接嵌在任何地方，通常放在代码<head>中；还可以将代码放到单独的.js文件，通过<script src="..."></script>引用，放入单独的.js文件更利于维护，不同页面可引用同一份.js文件 
1. 基本语法
以//开头直到行末的字符为注释；另一种多行字符注释/* ... */
2. 数据类型和变量
六大数据类型：
数字（不区分整数和浮点数，NaN也是数字类型，不等于任何数字包括自身）；	字符串；	布尔值；	null（表示一个空值）；	undefined（值未定义）；	对象（数组也是对象）
定义变量时可以不指定数据类型，这是动态语言的特性;JS不强迫必须用var定义变量，如果不用var则该变量为全局变量，可以用delete删除，通过在代码顶部输入‘use strict’ 可以强制要var定义
3. 字符串
字符串是基本数据类型，其值不能改变，'或"要成为字符输出的一部分需要在前面加转义符\,转义符还可以转移其他，如\n 换行 \t 制表符 \x## 与之十六进制对应的ASCII字符 \u####unicode字符
ES6使用`进行多行字符表示：
`这是一个
多行
字符串`
字符串操作：
String.length 求字符串长度；	String.toUpperCase()大写；	String.toLowerCase()小写；	String.indexOf()搜索某字符串出现的位置，没找到返回-1；	String.substring(0,5)返回指定区间的字串，不包括结束位置
4. 数组
数组可以改变，通过索引赋值索引超过了范围会引起数组大小的变化。
数组操作：
arr.indexOf()搜索特定元素的位置
arr.slice(n,n) 字符串substring的对应版，截取一部分返回新的数组，同样不包括结尾元素
arr.push() 数组末尾添加元素； arr.pop() 数组末尾删除元素
arr.unshift() 数组头添加元素； arr.shift() 数组头删除元素
arr.sort() 对数组进行排序，直接改变数组
arr.reverse() 给数组元素反转，直接改变数组
arr.splice(n,n,'element1',...,'element2') 从索引位置删除若干元素，再在该位置添加元素，第一个数字表示索引位置，第二个表示删除个数,直接改变数组
arr.concat() 连接另一个数组合并成一个，不改变原来的数组，返回新的
arr.join() 将数组元素按指定连接符连接成字符串
5. 对象
对象属性名如果不是有效变量则需要''括起来，访问也必须用[]操作符；要检测某对象Object拥有某属性可以用in操作符：'name' in xiaoming 返回布尔值，但该属性有可能是继承的不是自带的，要检测是不是自带的用Object.hasOwnProperty()
6. 循环
for ... in 循环是for循环的变体，for(var key in Object){} 中key表示的是对象Object的属性变量名
7. Map和Set
JS的对象属性名必须是字符串，为了增加其他的数据类型，ES6引入了新的数据类型Map，Map是一组键值对的结构。初始化一个Map需要一个二维数组，方法如下：
var m = new Map([['A',32],['B',42],['C',41]]);
也可以初始化一个空的Map，通过命令来添加键值对，同一个键只能有一个值，不断对同一个键赋值，后面的会将前面的覆盖
var m = new Map();
m.set('A',21);
Set是一组键的集合，不储存值，键不能重复
var s1 = new Set([1,2,3]);
s1.add(5); s1.delete(3);
8. iterable
类似数组的下标循环，但数组下标循环不能遍历Map和Set，为此引入了iterable类型，数组，Map，Set都属于iterable类型，这种类型可以通过for ... of 循环遍历，for（var value of iterable）中value表示值与for in不同
更好的方式是使用iterable的forEach（）方法：
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
});

二、函数
函数如果没有return则返回undefined，调用函数时传入的参数比定义的多也不影响调用，传入的比定义的少则返回NaN；函数中有个关键字arguments，包含所有传入的参数，类似数组但不是数组；剩余参数rest，
function name（a,b, ...rest){} rest包含所有a，b以后的所有参数，如果参数没有传到rest则rest为空数组，而不是undefined。
1. 变量作用域和解构赋值
JS具有变量申明提前的特性，但赋值不会提前；为了防止全局变量名的冲突，建议将所有全局变量和函数都放到一个对象中；用var定义的变量只有函数作用，要是变量有块级作用域用let申明变量；JS没有常量申明，默认变量名全部大写来标明常量
对多个变量进行同时赋值使用解构赋值：var [x,y,z] = ['A','B','C'];对对象进行解构赋值，多个变量要用{}括起来：
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school'
};
var {name, age, passport} = person;如果对象属性名不存在则赋值undefined，如果要给属性名不一致的变量名赋值可以使用下面的方法：
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school'
};
// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
var {name,single=true} = person;如果属性不存在则使用默认值true
有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：
// 声明变量:
var x, y;
// 解构赋值:
{x, y} = { name: '小明', x: 100, y: 200};
// 语法错误: Uncaught SyntaxError: Unexpected token =
这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：
({x, y} = { name: '小明', x: 100, y: 200});
2. 方法 
对象中绑定的函数称为该对象的方法
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};
xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
this是特殊对象始终指向当前对象，如果将其拆开写：
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25, 正常结果
getAge(); // NaN，在strict模式下回得到错误
单独调用this指向了window对象
如果方法函数里还嵌套了函数，this又会指向window
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - this.birth;
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined
解决办法是用that先捕获this
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};
xiaoming.age(); // 25
要指定函数的this指向那个对象，可以用函数本身的apply方法，它接受两个参数，第一个是要绑定的this变量，第二个是数组，包含函数本身的参数，用法如下：
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
另一个与apply（）类似的方法是call（），唯一的区别是apply把参数打包再传入，call把参数按顺序传入，如：
Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
对于普通函数，将this绑定为null
3. 高阶函数
参数接受另一个函数的函数称之为高阶函数
4. 闭包
一个函数的返回值是另一个函数称之为闭包，借助闭包可以封装私有变量
5.箭头函数
ES6新增了一种箭头函数，其格式如下：
(x,y)=> {
	return x*y;
}
箭头函数如果是单表达式可以省略{}和return
(x,y)=> x*y;
注意，如果返回一个对象省略return这样写会报错
x => {foo:x}
{}与函数体的{}有冲突，解决办法是在对象外加一个小括号({foo:x})
箭头函数内部的this是词法作用域，修复了匿名函数this绑定错误的问题
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25
由于this在箭头函数中已经按照词法作用域绑定了，用call或者apply调用箭头函数无法进行绑定，传入的第一个参数被忽略
6. generator
generator是ES6的一种新数据类型，类似于函数；generator由function*定义，除了return还可以用yield返回多次，格式如下：
function* foo(x){
	yield x+1;
	yield x+2;
	return x+3;
}
用生成斐波那契举个例子
function* fib(max) {
    var
        t,
        a = 0,
        b = 1,
        n = 0;
    while (n < max) {
        yield a;
        [a, b] = [b, a + b];
        n ++;
    }
    return;
}
直接调用，结果如下
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
fib(5)仅仅创建了一个对象，还没有执行，调用generator对象有两种方法，一是不断调用generator对象的next()方法：
var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
value就是yield的返回值，done表示generator是否已经执行结束，done为true，value就是return的返回值
第二个方法是直接使用for ... of 循环迭代generator对象：
for (var x of fib(5)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
generator还有另一个好处，可以把异步回调代码变成同步代码，这个好处学了AJAX才能体会，例子如下
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
}

三、 标准对象
JS里一切都视为对象（广义），可以通过typeof操作符获取对象类型，它总是返回一个字符串，如：typeof null; // 'object'
包装对象，用new创建number、boolean、string的包装对象：
var n = new Number(123);  //123
var b = new Boolean(true);  //true
var s = new String('str');  //'str'
他们的值没有发生变化，但类型已经变成了object，建议不要使用包装对象.如果直接使用Number、boolean、和string会被当成普通函数，其功能是将任何数据类型转换为number、boolean和string基本数据类型，不是对象
用parseInt()或parseFloat()来转换任意类型到number；
用String()来转换任意类型为string，或调用某个对象（广义）的toString()方法（null虽然是对象，但没有toString方法；
判断是不是数组：Array.isArray(arr);		
数字直接使用tostring方法如123.tostring()会报错，需要改为123..toString() 或 (123).toString();原因可能是123.被当成了浮点数
1. Date
Date对象用来表示日期和时间，获取系统当前时间如下；
var now = new Date();
now.getFullYear();年份
now.getMonth();月份
now.getDate();多少号
now.getDay();星期
now.getHours();时
now.getMinutes();分
now.getSeconds();秒
now.getMilliseconds();毫秒
now.getTime();以时间形式表示的时间戳
var d = new Date(2015,5,19,20,15,30,123); // 创建一个指定日期和时间的 Date对象，注意月份从零开始，1表示二月以此类推
第二种创建指定日期的date对象的方法是解析一个符合ISO 8601格式的字符串，它得到的是一个时间戳，
var d = Date.parse('2015-06-24T19:49:22.875+08:00');
d; // 143514656287
通过新建Date对象转为常用格式
var d = new Date(1435146562875);
d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
Date对象表示浏览器所在时区时间，也可以显示调整后的UTC时间：
var d = new Date(1435146562875);
d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时
2. RegExp正则表达式
\d 匹配数字； \w 匹配数字或字母； . 匹配任意一个字符； * 匹配零个或多个任意字符； + 匹配至少一个字符； ？ 匹配零个或一个字符； {n} 表示n个字符，{n,m}n-m个字符
[]表示范围，[0-9a-zA-Z]匹配一个数字或者一个字母； A|B 匹配A或者B； ^\d以数字开头；  $\d以数字结尾；  /.../i 忽略大小写  /.../m 执行多行匹配
创建正则表达式有两种方法：直接通过/正则表达式/; new RegExp('正则表达式’)
var re1 = /ABC\-001/;\在//中无需转义
var re2 = new RegExp('ABC\\-001');
re1; // /ABC\-001/
re2; // /ABC\-001/
RegExp对象的test()方法用于测试给定的字符串是否符合条件
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
用正则表达式提取字串，()里是要提取的分组，使用exec()方法提取，返回一个数组：
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
正则匹配时贪婪匹配，会尽可能多的匹配字符：
var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
禁止贪婪匹配可以加一个?
var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']
全局匹配，即在字符串中进行多次匹配直到找出所有的匹配项
var r1 = /test/g;
// 等价于:
var r2 = new RegExp('test', 'g');
全局匹配会与/^...$/冲突，这样只会匹配一次
3.JSON
JSON是一种用于数据交换的格式，它可以是任何数据类型以及它们的任意组合。JSON的字符集必须是UTF-8.
将一个对象序列化为JSON格式的字符串
var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp']
};
var s = JSON.stringify(xiaoming);
如果要输出好看，加上参数，按缩进输出：
JSON.stringify(xiaoming, null,' ');//一个空格表示缩进输出
第二个参数可以控制如何筛选键值：
JSON.stringify(xiaoming, ['name', 'skills'], '  ');
{
  "name": "小明",
  "skills": [
    "JavaScript",
    "Java",
    "Python",
    "Lisp"
  ]
}
还可以传入一个函数，对象的键值对会被函数先处理
function convert(key, value) {
    if (typeof value === 'string') {
        return value.toUpperCase();
    }
    return value;
}
JSON.stringify(xiaoming, convert, '  ');字符串变为：
{
  "name": "小明",
  "age": 14,
  "gender": true,
  "height": 1.65,
  "grade": null,
  "middle-school": "\"W3C\" MIDDLE SCHOOL",
  "skills": [
    "JAVASCRIPT",
    "JAVA",
    "PYTHON",
    "LISP"
  ]
}
精确控制如何序列化对象，可以给对象定义一个toJSON()方法，直接返回应该序列化的数据
var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],
    toJSON: function () {
        return { // 只输出name和age，并且改变了key：
            'Name': this.name,
            'Age': this.age
        };
    }
};
JSON.stringify(xiaoming); // '{"Name":"小明","Age":14}'
反序列化，使用JSON.parse()把一个JSON格式的字符串还原成对象
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse()可以接受一个函数，用来转换解析出来的属性
var obj = JSON.parse('{"name":"小明","age":14}', function (key, value) {
    if (key === 'name') {
        return value + '同学';
    }
    return value;
});
console.log(JSON.stringify(obj)); // {name: '小明同学', age: 14}

四、面向对象编程
JS中没有类和实例的概念，每个对象都是实例，JS是通过原型继承来实现面向对象编程的。
var Student = {
    name: 'Robot',
    height: 1.2,
    run: function () {
        console.log(this.name + ' is running...');
    }
};

var xiaoming = {
    name: '小明'
};
xiaoming.__proto__ = Student;
小明只有自己的name属性，其他都是从Student继承而来，如果将xiaoming指向其他的对象，之前继承对象的属性将不复存在
一般不直接用obj.__proto__去改变一个对象的原型，正确的方法是用Object.create()方法传入一个原型对象，并创建一个基于该原型的新对象，新对象没有任何自己的属性，需要添加
var Student = {
    name: 'Robot',
    height: 1.2,
    run: function () {
        console.log(this.name + ' is running...');
    }
};

function createStudent(name) {
    // 基于Student原型创建一个新对象:
    var s = Object.create(Student);
    // 初始化新对象:
    s.name = name;
    return s;
}

var xiaoming = createStudent('小明');
xiaoming.run(); // 小明 is running...
xiaoming.__proto__ === Student; // true
1. 创建对象
当访问一个对象的属性时，引擎先查找当前对象的属性，没有，查找其原型的对象上找，没有，到Object.prototype对象上找，没有，返回undefined
数组的原型链：arr ---> Array.prototype ---> Object.prototype ---> null 
函数原型链： functionName ---> Function.prototype ---> Object.prototype ---> null
使用new关键字和构造函数来创建一个对象。首先定义一个构造函数：
function Student(name) {
    this.name = name;
    this.hello = function () {
        alert('Hello, ' + this.name + '!');
    }
}
这实际是一个普通函数，利用关键字new来调用这个函数，会创建一个以该函数为原型的对象并返回这个对象，按照约定构造函数应当大写来区别普通函数：
var xiaoming = new Student('小明');
xiaoming.name; // '小明'
xiaoming.hello(); // Hello, 小明!
如果不写new这只是一个普通函数，返回undefined，写了new就是构造函数，它绑定的this指向新创建的对象，并默认返回this
新建对象xiaoming的原型链是：xiaoming ---> Student.prototype ---> Object.prototype ---> null
使用new Student() 创建的对象从原型上获得一个constructor属性，它指向函数Student本身，Student有个prototype属性，指向其原型对象
需要注意一点：
xiaoming.hello; // function: Student.hello()
xiaohong.hello; // function: Student.hello()
xiaoming.hello === xiaohong.hello; // false
虽然xiaoming和小红的方法代码一样，但是两个不同的函数
如果通过new Student()创建了很多对象，这些对象hello函数可以共享同一个函数，来节省空间，具体做法是将hello函数移动到Student.prototype对象上：
function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};
我们还可以编写一个createStudent()函数，在内部封装所有的new操作，
function Student(props) {
    this.name = props.name || '匿名'; // 默认值为'匿名'
    this.grade = props.grade || 1; // 默认值为1
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};

function createStudent(props) {
    return new Student(props || {})
}
这个createstudent()函数不需要new来调用；参数灵活，可以传，也可以不传
2. 原型继承

